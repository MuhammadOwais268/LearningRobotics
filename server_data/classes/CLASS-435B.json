{
    "Algorithm": {
        "levels": {
            "Education": {},
            "Serial Printing": {
                "description": ""
            }
        }
    },
    "Basic C++": {
        "levels": {
            "Basic Input/Output (I/O)": {
                "concept": {
                    "code": "#include <iostream>\n#include <string>\n\nint main() {\n    int userAge;\n    std::string userName;\n\n    std::cout << \"Please enter your name: \";\n    std::getline(std::cin, userName);\n\n    std::cout << \"Please enter your age: \";\n    std::cin >> userAge;\n\n    std::cout << \"\\nHello, \" << userName << \"!\" << std::endl;\n    std::cout << \"You are \" << userAge << \" years old.\" << std::endl;\n\n    return 0;\n}",
                    "explanation": "Explanation\n\nThis program interacts with the user by reading their input from the console.\n\nstd::cin is the standard character input stream (the keyboard).\n\nstd::getline(std::cin, userName);: This is the recommended way to read a full line of text, including spaces. It reads from std::cin and \n\nstores the result in the userName variable.\n\nstd::cin >> userAge;: The stream extraction operator >> reads data from the input and stores it in the variable. It stops reading when \n\nit encounters whitespace (like a space or newline), making it suitable for single words or numbers.\n",
                    "output": "Please enter your name: Jane Smith\nPlease enter your age: 30\n\nHello, Jane Smith!\nYou are 30 years old."
                },
                "description": "This program interacts with the user by reading their input from the console",
                "implementation": {
                    "code": "#include <Arduino.h>\n\n// Pin Definitions matching your wiring\n#define ENA 25\n#define IN1 14\n#define IN2 18\n#define ENB 26\n#define IN3 12\n#define IN4 5\n\nvoid setup() {\n  // Set all motor control pins to OUTPUT mode\n  pinMode(ENA, OUTPUT);\n  pinMode(IN1, OUTPUT);\n  pinMode(IN2, OUTPUT);\n  pinMode(ENB, OUTPUT);\n  pinMode(IN3, OUTPUT);\n  pinMode(IN4, OUTPUT);\n}\n\nvoid loop() {\n  // --- Move Forward ---\n  digitalWrite(IN1, HIGH);\n  digitalWrite(IN2, LOW);\n  digitalWrite(IN3, HIGH);\n  digitalWrite(IN4, LOW);\n  analogWrite(ENA, 200); // Set speed (0-255)\n  analogWrite(ENB, 200);\n  delay(2000);\n\n  // --- Stop ---\n  analogWrite(ENA, 0); // Speed = 0\n  analogWrite(ENB, 0);\n  delay(2000);\n\n  // --- Move Backward ---\n  digitalWrite(IN1, LOW);\n  digitalWrite(IN2, HIGH);\n  digitalWrite(IN3, LOW);\n  digitalWrite(IN4, HIGH);\n  analogWrite(ENA, 200);\n  analogWrite(ENB, 200);\n  delay(2000);\n\n  // --- Stop ---\n  analogWrite(ENA, 0);\n  analogWrite(ENB, 0);\n  delay(2000);\n}",
                    "explanation": "Concept: This level focuses on controlling the motors. It teaches how to configure the ESP32's pins as OUTPUTs using pinMode() and how to send signals to the motor driver with digitalWrite() (for direction) and analogWrite() (for speed).\nExplanation: We define all six motor control pins. In setup(), we declare them all as outputs. In the loop(), we create a simple sequence: move forward, stop, move backward, stop. We use digitalWrite() to set the IN pins to control direction and analogWrite() on the ENA/ENB pins to control the speed with a PWM signal."
                }
            },
            "Conditionals": {
                "concept": {
                    "code": "#include <iostream>\n\nint main() {\n    int score;\n    std::cout << \"Enter your test score (0-100): \";\n    std::cin >> score;\n\n    if (score >= 90) {\n        std::cout << \"You got an A!\" << std::endl;\n    }\n    else if (score >= 80) {\n        std::cout << \"You got a B.\" << std::endl;\n    }\n    else {\n        std::cout << \"You need to study more.\" << std::endl;\n    }\n\n    return 0;\n}",
                    "explanation": "Explanation\n\nThis program makes a decision based on the user's input.\n\nThe if statement checks a condition. If score >= 90 is true, its code block is executed, and the rest of the chain is skipped.\n\nIf the if condition is false, the program proceeds to the else if statement and checks its condition.\n\nThe else block is a catch-all. It executes only if all the preceding if and else if conditions in the chain were false. This creates a branching path in the program's logic.\n",
                    "output": "Enter your test score (0-100): 85\nYou got a B."
                },
                "description": "This program makes a decision based on users input",
                "implementation": {
                    "code": "#include <Arduino.h>\n#include <Wire.h>\n#include <VL53L0X.h>\n\n// Pins and motor functions from previous level\n#define ENA 25\n#define IN1 14\n#define IN2 18\n#define ENB 26\n#define IN3 12\n#define IN4 5\n\nVL53L0X sensor;\n\nvoid moveForward(int speed) { digitalWrite(IN1, HIGH); digitalWrite(IN2, LOW); digitalWrite(IN3, HIGH); digitalWrite(IN4, LOW); analogWrite(ENA, speed); analogWrite(ENB, speed); }\nvoid moveStop() { analogWrite(ENA, 0); analogWrite(ENB, 0); }\nvoid turnRight(int speed) { digitalWrite(IN1, HIGH); digitalWrite(IN2, LOW); digitalWrite(IN3, LOW); digitalWrite(IN4, HIGH); analogWrite(ENA, speed); analogWrite(ENB, speed); }\n\nvoid setup() {\n  Wire.begin();\n  pinMode(ENA, OUTPUT); pinMode(IN1, OUTPUT); pinMode(IN2, OUTPUT);\n  pinMode(ENB, OUTPUT); pinMode(IN3, OUTPUT); pinMode(IN4, OUTPUT);\n  sensor.setTimeout(500);\n  if (!sensor.init()) { while (1) {} }\n  sensor.startContinuous();\n}\n\nvoid loop() {\n  // SENSE: Read the distance\n  int distance = sensor.readRangeContinuousMillimeters();\n  bool isValidReading = !sensor.timeoutOccurred();\n\n  // THINK: Make a decision with an if-else statement\n  if (distance < 200 && isValidReading) {\n    // ACT: Obstacle is close, so turn\n    turnRight(180);\n    delay(500); // Turn for a fixed duration\n  } else {\n    // ACT: Path is clear, so move forward\n    moveForward(200);\n  }\n}",
                    "explanation": "Concept: This is where the robot gets \"smart.\" if-else statements allow the robot to make decisions. It checks the sensor reading and executes different functions based on the result.\nExplanation: The loop() now constantly reads the distance sensor. It uses an if statement to check if (distance < 200). If this condition is true (an obstacle is close), it runs the code inside the if block (stop and turn). If the condition is false, it runs the code inside the else block (move forward). This creates the core obstacle-avoiding behavior."
                }
            },
            "First C++ Program": {
                "concept": {
                    "code": "// Include the Input/Output Stream library\n#include <iostream>\n\n// All C++ programs start execution in the main function\nint main() {\n    // std::cout sends text to the console.\n    // << is the stream insertion operator.\n    // \"Hello, World!\" is the text to be printed.\n    // std::endl adds a new line and flushes the output.\n    std.cout << \"Hello, World!\" << std::endl;\n\n    // Return 0 to indicate that the program finished successfully.\n    return 0;\n}",
                    "explanation": "Code Explanation:\n#include <iostream>: Prepares your program to use tools for input and output.\n\nint main(): Defines the main function where the program begins. int means it will return an integer value when it's done.\n\nstd::cout: This is the \"standard character output\" stream, which usually means the console or terminal. The std:: part means cout is \n\nlocated in the standard (std) namespace.\n\n<<: The stream insertion operator. It \"inserts\" the data on its right into the stream on its left.\n\nstd::endl: Inserts a newline character, so the next output will start on a new line.\n\nreturn 0;: This is a status code sent to the operating system. A return value of 0 conventionally means \"everything went okay.\"",
                    "output": "Hello, World!"
                },
                "description": "Hello World it swas first ever written program",
                "implementation": {
                    "code": "#include <Arduino.h>\n#include <Wire.h>\n#include <Adafruit_GFX.h>\n#include <Adafruit_SSD1306.h>\n\n#define SCREEN_WIDTH 128\n#define SCREEN_HEIGHT 64\n\nAdafruit_SSD1306 display(SCREEN_WIDTH, SCREEN_HEIGHT, &Wire, -1);\n\nvoid setup() {\n  // Start I2C communication (required for the OLED)\n  Wire.begin();\n\n  // Initialize the display\n  if (!display.begin(SSD1306_SWITCHCAPVCC, 0x3C)) {\n    for (;;); // If it fails, halt the program\n  }\n\n  // --- Main Actions ---\n  display.clearDisplay();\n  display.setTextSize(2);\n  display.setTextColor(WHITE);\n  display.setCursor(10, 10);\n  display.println(\"Hello\");\n  display.println(\" Robot!\");\n  display.display(); // Push the text to the screen\n}\n\nvoid loop() {\n  // The screen is static, so nothing needs to be repeated here.\n}",
                    "explanation": "Concept: This is the \"Hello, World!\" of embedded systems. It teaches the basic structure of an Arduino/PlatformIO program (setup() and loop()) by initializing the OLED screen and displaying a static message.\nExplanation: The setup() function runs only once at the start. We use it to initialize the OLED display. We clear its memory, set the text size and color, position the cursor, and write \"Hello Robot!\". The display() command pushes this information to the screen. The loop() function is empty because we don't need to update the screen after the initial message."
                }
            },
            "Functions": {
                "concept": {
                    "code": "#include <iostream>\n\n// Function Declaration (Prototype)\nint add(int num1, int num2);\n\nint main() {\n    int a = 5;\n    int b = 7;\n\n    // Function Call\n    int sum = add(a, b);\n\n    std::cout << \"The sum is \" << sum << std::endl;\n    return 0;\n}\n\n// Function Definition\nint add(int num1, int num2) {\n    return num1 + num2;\n}```\n\n",
                    "explanation": "This program defines and uses a function to make the code more organized and reusable.\n\nFunction Declaration: int add(int num1, int num2); is a prototype that tells the compiler about the function before main uses it. It \nspecifies the function's name, the data types of its parameters (int, int), and its return type (int).\n\nFunction Call: In main, the line int sum = add(a, b); executes the function. The values of a and b are passed as arguments. The function's return value is captured in the sum variable.\n\nFunction Definition: This is the actual block of code that runs when the function is called. It takes the arguments, performs the addition, and uses the return keyword to send the result back to the caller.\n",
                    "output": "#### Expected Output\n```text\nThe sum is 12"
                },
                "description": "This program defines and uses a function to make the code more organized and reusable",
                "implementation": {
                    "code": "#include <Arduino.h>\n\n// Pin Definitions\n#define ENA 25\n#define IN1 14\n#define IN2 18\n#define ENB 26\n#define IN3 12\n#define IN4 5\n\n// A function to move the robot forward at a given speed\nvoid moveForward(int speed) {\n  digitalWrite(IN1, HIGH);\n  digitalWrite(IN2, LOW);\n  digitalWrite(IN3, HIGH);\n  digitalWrite(IN4, LOW);\n  analogWrite(ENA, speed);\n  analogWrite(ENB, speed);\n}\n\n// A function to stop both motors\nvoid moveStop() {\n  analogWrite(ENA, 0);\n  analogWrite(ENB, 0);\n}\n\n// A function to pivot the robot to the right\nvoid turnRight(int speed) {\n  digitalWrite(IN1, HIGH); // Left motor forward\n  digitalWrite(IN2, LOW);\n  digitalWrite(IN3, LOW);  // Right motor backward\n  digitalWrite(IN4, HIGH);\n  analogWrite(ENA, speed);\n  analogWrite(ENB, speed);\n}\n\nvoid setup() {\n  pinMode(ENA, OUTPUT); pinMode(IN1, OUTPUT); pinMode(IN2, OUTPUT);\n  pinMode(ENB, OUTPUT); pinMode(IN3, OUTPUT); pinMode(IN4, OUTPUT);\n}\n\nvoid loop() {\n  // The loop is now much easier to read by calling functions\n  moveForward(200);\n  delay(2000);\n\n  moveStop();\n  delay(1000);\n\n  turnRight(180);\n  delay(1000);\n\n  moveStop();\n  delay(2000);\n}",
                    "explanation": "Concept: Making code cleaner and reusable by creating named blocks of code called functions. This avoids repetition and makes the main program logic much easier to read.\nExplanation: We take the repetitive blocks of digitalWrite and analogWrite calls from Level 3 and wrap them in functions like moveForward(int speed). Now, the loop() is very simple and readable. To make the robot move forward, we just call moveForward(200);. The int speed parameter makes the function flexible."
                }
            },
            "Loops": {
                "concept": {
                    "code": "#include <iostream>\n\nint main() {\n    // --- for loop ---\n    std::cout << \"--- For Loop ---\" << std::endl;\n    for (int i = 1; i <= 4; ++i) {\n        std::cout << \"Iteration number \" << i << std::endl;\n    }\n\n    // --- while loop ---\n    std::cout << \"\\n--- While Loop ---\" << std::endl;\n    int countdown = 3;\n    while (countdown > 0) {\n        std::cout << countdown << \"...\" << std::endl;\n        countdown = countdown - 1; // or countdown--;\n    }\n    std::cout << \"Lift off!\" << std::endl;\n\n    return 0;\n}",
                    "explanation": "Explanation\n\nThis program demonstrates the two most common types of loops.\n\nA for loop is ideal when you know exactly how many times you want to repeat an action. The statement for (int i = 1; i <= 4; ++i) does three things: 1) initializes i to 1, 2) sets the condition to loop as long as i is less than or equal to 4, and 3) increments i after each loop iteration.\n\nA while loop is used to repeat as long as a condition remains true. The loop checks while (countdown > 0) before each iteration. The value of countdown must be changed inside the loop to prevent it from running forever (an infinite loop).",
                    "output": "--- For Loop ---\nIteration number 1\nIteration number 2\nIteration number 3\nIteration number 4\n\n--- While Loop ---\n3...\n2...\n1...\nLift off!"
                },
                "description": "This program demonstrates the two most common types of loops",
                "implementation": {
                    "code": "#include <Arduino.h>\n#include <Wire.h>\n#include <VL53L0X.h>\n#include <Adafruit_GFX.h>\n#include <Adafruit_SSD1306.h>\n\n// Pin Definitions\n#define ENA 25\n#define IN1 14\n#define IN2 18\n#define ENB 26\n#define IN3 12\n#define IN4 5\n\n// Behavior Constants\n#define OBSTACLE_THRESHOLD 200\n#define NORMAL_SPEED 200\n#define TURN_SPEED 180\n\n// Hardware Objects\nVL53L0X sensor;\nAdafruit_SSD1306 display(128, 64, &Wire, -1);\n\n// Robot Action Functions\nvoid moveForward(int speed) { digitalWrite(IN1, HIGH); digitalWrite(IN2, LOW); digitalWrite(IN3, HIGH); digitalWrite(IN4, LOW); analogWrite(ENA, speed); analogWrite(ENB, speed); }\nvoid moveBackward(int speed) { digitalWrite(IN1, LOW); digitalWrite(IN2, HIGH); digitalWrite(IN3, LOW); digitalWrite(IN4, HIGH); analogWrite(ENA, speed); analogWrite(ENB, speed); }\nvoid turnRight(int speed) { digitalWrite(IN1, HIGH); digitalWrite(IN2, LOW); digitalWrite(IN3, LOW); digitalWrite(IN4, HIGH); analogWrite(ENA, speed); analogWrite(ENB, speed); }\nvoid moveStop() { analogWrite(ENA, 0); analogWrite(ENB, 0); }\n\nvoid setup() {\n  Wire.begin();\n  pinMode(ENA, OUTPUT); pinMode(IN1, OUTPUT); pinMode(IN2, OUTPUT);\n  pinMode(ENB, OUTPUT); pinMode(IN3, OUTPUT); pinMode(IN4, OUTPUT);\n  if (!display.begin(SSD1306_SWITCHCAPVCC, 0x3C)) { for(;;); }\n  sensor.setTimeout(500);\n  if (!sensor.init()) { while (1); }\n  sensor.startContinuous();\n}\n\nvoid loop() {\n  int distance = sensor.readRangeContinuousMillimeters();\n  bool isValidReading = !sensor.timeoutOccurred();\n\n  display.clearDisplay();\n  display.setTextColor(WHITE);\n  display.setTextSize(2);\n  display.setCursor(0, 0);\n  display.print(\"Dist: \");\n  display.print(distance);\n\n  if (distance < OBSTACLE_THRESHOLD && isValidReading) {\n    display.setCursor(0, 20);\n    display.print(\"OBSTACLE!\");\n    display.display();\n    \n    // Escape Maneuver\n    moveBackward(NORMAL_SPEED);\n    delay(300);\n    turnRight(TURN_SPEED);\n    \n    // Use a 'for' loop to blink a turning indicator\n    display.setTextSize(1);\n    for (int i = 0; i < 4; i++) {\n        display.setCursor(0, 40);\n        display.print(\"Turning...  \");\n        display.display();\n        delay(100);\n        display.setCursor(0, 40);\n        display.print(\"Turning... *\");\n        display.display();\n        delay(100);\n    } // The turn lasts for 4 * 200ms = 800ms\n    moveStop();\n    delay(100);\n  } else {\n    display.setCursor(0, 20);\n    display.print(\"All Clear\");\n    moveForward(NORMAL_SPEED);\n    display.display();\n  }\n  \n  delay(50);\n}",
                    "explanation": "Concept: This final program integrates all previous concepts and adds a for loop to create a more refined behavior. The for loop is used to repeat an action a specific number of times.\nExplanation: This version combines everything: sensor, motors, and OLED. When an obstacle is detected, the robot performs a more complex escape maneuver (back up, then turn). A for loop is used to blink a status message on the OLED screen multiple times while the robot is turning, providing clear visual feedback. This demonstrates a practical use for a loop inside the main loop()."
                }
            },
            "Variables & Datatypes": {
                "concept": {
                    "code": "#include <iostream>\n#include <string> // Required for using the string data type\n\nint main() {\n    int age = 25;\n    double temperature = 98.6;\n    char grade = 'A';\n    bool isStudent = true;\n    std::string name = \"John Doe\";\n\n    std::cout << \"Name: \" << name << std::endl;\n    std::cout << \"Age: \" << age << std::endl;\n    std::cout << \"Is a student? \" << isStudent << std::endl; // Prints 1 for true\n\n    return 0;\n}",
                    "explanation": "This program demonstrates how to declare and use variables of different fundamental types.\n\nA variable is a named storage location for data.\n\nint age = 25;: Declares an integer variable age to hold whole numbers.\n\ndouble temperature = 98.6;: Declares a double-precision floating-point variable temperature for numbers with decimal points.\n\nchar grade = 'A';: Declares a character variable grade to hold a single character (enclosed in single quotes).\n\nbool isStudent = true;: Declares a boolean variable isStudent which can only be true or false. When printed, true is output as 1 and \nfalse as 0.\n\nstd::string name = \"John Doe\";: Declares a string variable name for holding text (enclosed in double quotes). You must #include \n\n<string> to use it.\n",
                    "output": "Name: John Doe\nAge: 25\nIs a student? 1"
                },
                "description": "This program demonstrates how to declare and use variables of different fundamental types",
                "implementation": {
                    "code": "#include <Arduino.h>\n#include <Wire.h>\n#include <VL53L0X.h> // Include the Pololu sensor library\n#include <Adafruit_GFX.h>\n#include <Adafruit_SSD1306.h>\n\n#define SCREEN_WIDTH 128\n#define SCREEN_HEIGHT 64\n\nVL53L0X sensor;\nAdafruit_SSD1306 display(SCREEN_WIDTH, SCREEN_HEIGHT, &Wire, -1);\n\n// A variable of datatype 'int' to store a whole number\nint distance_mm = 0; \n// A variable of datatype 'bool' to store a true/false value\nbool sensor_ok = false;\n\nvoid setup() {\n  Wire.begin();\n  display.begin(SSD1306_SWITCHCAPVCC, 0x3C);\n\n  // Initialize the sensor and store the result in our boolean variable\n  sensor.setTimeout(500);\n  if (sensor.init()) {\n    sensor_ok = true;\n    sensor.startContinuous();\n  }\n  \n  // Display status based on the boolean variable's value\n  display.clearDisplay();\n  display.setTextSize(1);\n  display.setTextColor(WHITE);\n  display.setCursor(0, 0);\n  if (sensor_ok) {\n    display.println(\"Sensor... OK\");\n  } else {\n    display.println(\"Sensor... FAILED\");\n  }\n  display.display();\n  delay(2000);\n}\n\nvoid loop() {\n  // Store the latest sensor reading in our integer variable\n  distance_mm = sensor.readRangeContinuousMillimeters();\n\n  // Display the content of the variable on the screen\n  display.clearDisplay();\n  display.setTextSize(2);\n  display.setCursor(0, 0);\n  display.print(\"Dist:\");\n  display.setCursor(0, 20);\n  display.print(distance_mm); // This prints the number stored in the variable\n  display.print(\" mm\");\n  display.display();\n  \n  delay(100);\n}",
                    "explanation": "Concept: This level introduces variables as named containers for data. We use an int (integer) variable to store the distance from the sensor and a bool (true/false) variable to track the sensor's status, demonstrating how data can be stored, updated, and displayed.\nExplanation: We declare a global variable distance_mm of type int. In the loop(), we read the sensor's value and store the result in this variable. We then clear the OLED and print the text \"Dist:\" followed by the value currently stored inside distance_mm. This shows how a variable's content can change with each loop.\n"
                }
            }
        }
    },
    "Control System": {
        "levels": {}
    },
    "OPP": {
        "levels": {
            "Arrays ": {
                "concept": {
                    "code": "#include <iostream>\n#include <vector> // Required for using std::vector\n\n// A simple class to store 2D coordinates.\nclass Vector2D {\npublic:\n    float x;\n    float y;\n    Vector2D(float startX, float startY) : x(startX), y(startY) {}\n\n    void print() {\n        std::cout << \"(\" << x << \", \" << y << \")\" << std::endl;\n    }\n};\n\nint main() {\n    // 1. DECLARATION\n    // Create a vector (a dynamic array) that will hold a list of Vector2D objects.\n    // It starts empty.\n    std::vector<Vector2D> pathWaypoints;\n    \n    // 2. ADDING ELEMENTS\n    // Use the .push_back() method to add elements to the end of the array.\n    std::cout << \"Adding waypoints to the path...\" << std::endl;\n    pathWaypoints.push_back(Vector2D(0.0f, 0.0f));   // This becomes element at index 0\n    pathWaypoints.push_back(Vector2D(10.0f, 5.0f));  // This becomes element at index 1\n    pathWaypoints.push_back(Vector2D(12.0f, 15.0f)); // This becomes element at index 2\n\n    std::cout << \"The path now has \" << pathWaypoints.size() << \" waypoints.\" << std::endl;\n\n    std::cout << \"\\n--- Iterating through the array to process the path ---\" << std::endl;\n    \n    // 3. ITERATION and ACCESSING ELEMENTS\n    // A 'for' loop is the perfect tool to visit every element in an array.\n    // The loop runs as long as 'i' is less than the total size of the array.\n    for (int i = 0; i < pathWaypoints.size(); ++i) {\n        std::cout << \"Processing waypoint with index \" << i << \": \";\n        \n        // Use the index 'i' to access the element at that position.\n        pathWaypoints[i].print();\n    }\n    \n    return 0;\n}",
                    "explanation": "Arrays\n\nHigh-Level Concept:\nAn array is an ordered list used for storing multiple items of the exact same data type. It's the most fundamental way to manage a collection of data in almost any programming language.\n\nAnalogy:\nThink of an array as a row of numbered lockers in a hallway.\n\nSame Type: Every locker is designed to hold the same kind of item (e.g., all lockers hold a Vector2D object, you can't put a string in one).\n\nOrdered: The lockers are in a specific, numbered sequence: 0, 1, 2, 3, and so on.\n\nDirect Access: If you know the locker number (the index), you can go directly to it without checking the others. This is called random access and it's very fast.\n\nIndex Starts at 0: Crucially, in programming, the first locker is always numbered 0.",
                    "output": "Adding waypoints to the path...\nThe path now has 3 waypoints.\n\n--- Iterating through the array to process the path ---\nProcessing waypoint with index 0: (0, 0)\nProcessing waypoint with index 1: (10, 5)\nProcessing waypoint with index 2: (12, 15)"
                },
                "description": "An array is an ordered list used for storing multiple items of the exact same data type. It's the most fundamental way to manage a collection of data .",
                "implementation": {
                    "code": "#include <Arduino.h>\n#include <vector> // Required for using std::vector (dynamic array)\n\n// --- Pin Definitions ---\n#define ENA 25\n#define IN1 14\n#define IN2 18\n#define ENB 26\n#define IN3 12\n#define IN4 5\n\n// =================================================================\n// CONCEPT: ARRAYS\n// =================================================================\n\n// 1. Declaration: Create a vector (an array) to hold a list of motor speeds.\nstd::vector<int> speedSequence;\nint currentStep = 0; // An index to track our position in the array\n\nvoid setup() {\n    Serial.begin(115200);\n    delay(1000);\n    Serial.println(\"--- Program Start: Arrays ---\");\n\n    pinMode(ENA, OUTPUT); pinMode(IN1, OUTPUT); pinMode(IN2, OUTPUT);\n    pinMode(ENB, OUTPUT); pinMode(IN3, OUTPUT); pinMode(IN4, OUTPUT);\n\n    // 2. Adding Elements: Populate our array with a sequence of actions.\n    // Positive values = forward speed, Negative = backward, 0 = stop.\n    speedSequence.push_back(150); // Step 0: Move forward slow\n    speedSequence.push_back(255); // Step 1: Move forward fast\n    speedSequence.push_back(0);   // Step 2: Stop\n    speedSequence.push_back(-200);// Step 3: Move backward\n    speedSequence.push_back(0);   // Step 4: Stop\n}\n\nvoid loop() {\n    // 3. Accessing Elements: Get the speed from the array at the current step.\n    int currentSpeed = speedSequence[currentStep];\n\n    Serial.print(\"Executing step \");\n    Serial.print(currentStep);\n    Serial.print(\": Speed = \");\n    Serial.println(currentSpeed);\n\n    if (currentSpeed > 0) {\n        // Move forward\n        digitalWrite(IN1, HIGH); digitalWrite(IN2, LOW);\n        digitalWrite(IN3, HIGH); digitalWrite(IN4, LOW);\n        analogWrite(ENA, currentSpeed); analogWrite(ENB, currentSpeed);\n    } else if (currentSpeed < 0) {\n        // Move backward\n        digitalWrite(IN1, LOW); digitalWrite(IN2, HIGH);\n        digitalWrite(IN3, LOW); digitalWrite(IN4, HIGH);\n        analogWrite(ENA, -currentSpeed); analogWrite(ENB, -currentSpeed);\n    } else {\n        // Stop\n        analogWrite(ENA, 0); analogWrite(ENB, 0);\n    }\n\n    // Move to the next index in the array for the next loop iteration.\n    currentStep++;\n    // If we've reached the end of the array, loop back to the beginning.\n    if (currentStep >= speedSequence.size()) {\n        currentStep = 0;\n        Serial.println(\"--- Sequence restarting ---\");\n    }\n\n    delay(2000); // Hold each action for 2 seconds\n}",
                    "explanation": "Arrays\n\nGoal: To teach how to use an array (std::vector) to store a sequence of actions for the robot to perform.\n\nConcept Explained: An Array is an ordered list. In this program, we create an array of ints named speedSequence. This array holds a pre-programmed list of motor speeds. The loop() iterates through this array using an index (i). In each iteration, it retrieves a speed value from the array (speedSequence[i]) and commands the motors to run at that speed, demonstrating how an array can be used to choreograph a robot's behavior.\n"
                }
            },
            "Class and Objects": {
                "concept": {
                    "code": "#include <iostream>\n\n// The blueprint for a 2D vector.\nclass Vector2D {\npublic: // 'public' means these can be accessed from outside the class.\n    // Attributes: Every Vector2D will have its own x and y.\n    float x;\n    float y;\n\n    // Constructor: This method is called automatically when a new object is created.\n    // Its job is to initialize the object's attributes.\n    Vector2D(float startX, float startY) {\n        x = startX;\n        y = startY;\n        std::cout << \"[Constructor Called] Vector2D object created.\" << std::endl;\n    }\n\n    // Method: A function that belongs to the class.\n    void print() {\n        std::cout << \"(\" << x << \", \" << y << \")\" << std::endl;\n    }\n};\n\nint main() {\n    // We are now creating two distinct OBJECTS from the Vector2D CLASS.\n    Vector2D playerPosition(10.0f, 20.0f);\n    Vector2D enemyVelocity(-5.0f, 0.0f);\n\n    std::cout << \"\\nPlayer Position is an object with its own data: \";\n    playerPosition.print(); // Calls the print() method belonging to this object.\n\n    std::cout << \"Enemy Velocity is a separate object with its own data: \";\n    enemyVelocity.print(); // Calls the print() method on a different object.\n\n    return 0;\n}",
                    "explanation": "Classes and Objects\nHigh-Level Concept: A class is a blueprint; an object is the actual thing built from that blueprint.\n\nAnalogy:\nThink of an architectural blueprint for a house. The blueprint is the Class. It defines what all houses of its type must have: doors, windows, a foundation, etc. It also defines what they can do: doors can open, windows can slide.\n\nThe actual houses built from this blueprint are the Objects. House A and House B are both objects of the House class. They share the same structure but are independent: House A can be painted blue, while House B is red. Opening the door of House A does not \nopen the door of House B.\n\n\nHow it Works in Code:\n\n\tThe class Vector2D { ... }; block is the blueprint.\n\n\tThe float x; float y; inside are the attributes, the properties defined in the blueprint.\n\n\tThe Vector2D(float startX, float startY) is the constructor. This is like the part of the blueprint that says, \"When you start               building, you must specify the initial coordinates.\"\n\n\tVector2D playerPosition(10.0f, 20.0f); is the act of construction. You are creating a specific, real Vector2D object n\tamed playerPosition. This object now has its own x and y variables set to 10 and 20.\n",
                    "output": "[Constructor Called] Vector2D object created.\n[Constructor Called] Vector2D object created.\n\nPlayer Position is an object with its own data: (10, 20)\nEnemy Velocity is a separate object with its own data: (-5, 0)"
                },
                "description": "A class is a blueprint; an object is the actual thing built from that blueprint.",
                "implementation": {
                    "code": "#include <Arduino.h>\n#include <Wire.h>\n#include <VL53L0X.h>\n#include <Adafruit_GFX.h>\n#include <Adafruit_SSD1306.h>\n\n// --- Pin Definitions ---\n#define ENA 25\n#define IN1 14\n#define IN2 18\n#define ENB 26\n#define IN3 12\n#define IN4 5\n\n// =================================================================\n// CONCEPT: CLASSES AND OBJECTS\n// =================================================================\n\n// The CLASS (the blueprint for our robot)\nclass Robot {\npublic:\n    // Attributes: The hardware components the robot possesses.\n    // These are objects of other classes provided by the libraries.\n    VL53L0X sensor;\n    Adafruit_SSD1306 display;\n\n    // Constructor: Runs when a Robot object is created.\n    Robot() : display(128, 64, &Wire, -1) { // Initialize the display object\n        Serial.println(\"Robot object created in memory.\");\n    }\n\n    // Method: A behavior. This initializes all the hardware.\n    void initializeHardware() {\n        Wire.begin();\n        pinMode(ENA, OUTPUT); pinMode(IN1, OUTPUT); pinMode(IN2, OUTPUT);\n        pinMode(ENB, OUTPUT); pinMode(IN3, OUTPUT); pinMode(IN4, OUTPUT);\n\n        if (!display.begin(SSD1306_SWITCHCAPVCC, 0x3C)) {\n            Serial.println(\"OLED allocation failed\");\n            for(;;);\n        }\n        sensor.setTimeout(500);\n        if (!sensor.init()) {\n            Serial.println(\"Sensor Failed!\");\n            while(1);\n        }\n        sensor.startContinuous();\n        Serial.println(\"All robot hardware initialized.\");\n    }\n\n    // Method: Reports the sensor reading to the OLED display.\n    void reportStatus() {\n        int distance = sensor.readRangeContinuousMillimeters();\n        \n        display.clearDisplay();\n        display.setTextSize(2);\n        display.setTextColor(WHITE);\n        display.setCursor(0, 0);\n        display.print(\"Dist: \");\n        display.print(distance);\n        display.print(\"mm\");\n        display.display();\n    }\n};\n\n// --- Create a global OBJECT from the Robot CLASS ---\nRobot myBot;\n\nvoid setup() {\n    Serial.begin(9600);\n    delay(1000);\n    \n    // Command our object to initialize its hardware.\n    myBot.initializeHardware();\n}\n\nvoid loop() {\n    // Repeatedly command our object to report its status.\n    myBot.reportStatus();\n    delay(100);\n}",
                    "explanation": "Classes and Objects\n\nGoal: To teach the concept of a class as a blueprint for your robot and an object as the working instance that controls the hardware.\n\nConcept Explained: We define a Robot Class (the blueprint). This blueprint states that every robot must have motor pins, a sensor, a display, and the ability to initialize() its systems and reportStatus(). In the global scope, we create a single, tangible Object named myBot from this blueprint. The setup() and loop() functions then command this single object to perform actions, and the object uses its internal hardware objects to interact with the real world."
                }
            },
            "Inheritance": {
                "concept": {
                    "code": "#include <iostream>\n#include <string>\n\nclass Vector2D {\npublic:\n    float x=0, y=0; Vector2D(float sX, float sY) : x(sX), y(sY) {}\n    void print() { std::cout << \"(\" << x << \", \" << y << \")\" << std::endl; }\n};\n\n// Parent Class: Defines properties common to all objects in our game world.\nclass GameObject {\npublic:\n    Vector2D position;\n    GameObject(float startX, float startY) : position(startX, startY) {}\n    void reportPosition() {\n        std::cout << \"Position: \";\n        position.print();\n    }\n};\n\n// Child Class: Inherits from GameObject and adds robot-specific details.\nclass Robot : public GameObject {\npublic:\n    std::string name;\n    int battery_level;\n\n    // The child constructor calls the parent constructor first.\n    Robot(std::string robotName, float startX, float startY) : GameObject(startX, startY) {\n        name = robotName;\n        battery_level = 100;\n    }\n\n    // This method uses both its own data and inherited methods.\n    void reportStatus() {\n        std::cout << \"Status for robot '\" << name << \"':\" << std::endl;\n        reportPosition(); // This method is inherited from GameObject.\n        std::cout << \"Battery: \" << battery_level << \"%.\" << std::endl;\n    }\n};\n\nint main() {\n    // When we create a Robot, it's also a GameObject.\n    Robot r2d2(\"R2-D2\", 50.0f, 75.0f);\n    r2d2.reportStatus();\n    return 0;\n}",
                    "explanation": "High-Level Concept: Reusing and extending existing blueprints to create specialized versions.\n\nAnalogy:\n\nThink of vehicles. You could have a base blueprint for a Vehicle (the parent class). It would define that all vehicles have a speed and can startEngine(). From this, you could create a more specific blueprint for a Car (the child class). A Car is a Vehicle, so it automatically inherits speed and startEngine(). It can then add its own properties (like numberOfDoors) and its own methods (like turnOnWipers()).\n\nHow it Works in Code:\n\tclass Robot : public GameObject is the C++ syntax for \"The Robot class is a child of the GameObject class.\"\n\n\tGameObject is the parent (or base) class. Robot is the child (or derived) class.\n\n\tThe Robot constructor Robot(...) : GameObject(...) is crucial. It first calls the constructor of its parent (GameObject) to \t\ninitialize the parts it's inheriting (the position). After the parent part is built, it then runs its own constructor code to initialize its specific \tattributes (name, battery_level).\n\n\tA Robot object can now use methods from both itself (reportStatus()) and its parent (reportPosition()).",
                    "output": "Status for robot 'R2-D2':\nPosition: (50, 75)\nBattery: 100%.```\n\n---"
                },
                "description": "Resing and extending existing blueprints to create specialized versions",
                "implementation": {
                    "code": "#include <Arduino.h>\n#include <Wire.h>\n#include <string>\n#include <VL53L0X.h>\n#include <Adafruit_GFX.h>\n#include <Adafruit_SSD1306.h>\n\n// =================================================================\n// CONCEPT: INHERITANCE\n// =================================================================\n\n// PARENT CLASS (Base Class)\nclass Device {\npublic:\n    std::string status;\n    Device() { status = \"Unitialized\"; }\n};\n\n// CHILD CLASS: An OLED_Display 'is-a' Device.\nclass OLED_Display : public Device {\npublic:\n    Adafruit_SSD1306 oled; // It contains the actual hardware object\n\n    OLED_Display() : oled(128, 64, &Wire, -1) {}\n\n    bool initialize() {\n        if (oled.begin(SSD1306_SWITCHCAPVCC, 0x3C)) {\n            status = \"OK\"; // It can access the inherited 'status' variable\n            return true;\n        }\n        status = \"FAILED\";\n        return false;\n    }\n\n    // A method unique to this child class\n    void displayText(const char* text) {\n        oled.clearDisplay(); oled.setTextSize(2); oled.setTextColor(WHITE);\n        oled.setCursor(0, 10); oled.println(text); oled.display();\n    }\n};\n\n// Another CHILD CLASS: A DistanceSensor 'is-a' Device.\nclass DistanceSensor : public Device {\npublic:\n    VL53L0X lox;\n\n    bool initialize() {\n        lox.setTimeout(500);\n        if (lox.init()) {\n            status = \"OK\";\n            lox.startContinuous();\n            return true;\n        }\n        status = \"FAILED\";\n        return false;\n    }\n\n    // A method unique to this child\n    int readDistance() {\n        return lox.readRangeContinuousMillimeters();\n    }\n};\n\n// Create objects of our specialized child classes.\nOLED_Display myDisplay;\nDistanceSensor mySensor;\n\nvoid setup() {\n    Serial.begin(115200);\n    Wire.begin();\n    delay(1000);\n    Serial.println(\"--- Program Start: Inheritance ---\\n\");\n    \n    myDisplay.initialize();\n    mySensor.initialize();\n    \n    Serial.print(\"Display Status: \");\n    Serial.println(myDisplay.status.c_str()); // Accessing inherited property\n    Serial.print(\"Sensor Status: \");\n    Serial.println(mySensor.status.c_str()); // Accessing inherited property\n}\n\nvoid loop() {\n  int distance = mySensor.readDistance();\n  myDisplay.displayText(std::to_string(distance).c_str());\n  delay(100);\n}",
                    "explanation": "Inheritance\n\nGoal: To teach how a child class can reuse and extend a parent class to create specialized hardware controllers.\n\nConcept Explained: We define a generic parent class, Device, which has a common status. We then create two child classes: OLED_Display and DistanceSensor. The syntax : public Device means they inherit from Device. They automatically get the status attribute. Each child then adds its own unique hardware object and methods (displayText(), readDistance()). This demonstrates how to build a logical hierarchy, reusing common code (status) while creating specialized components.\n"
                }
            },
            "Pointers": {
                "concept": {
                    "code": "#include <iostream>\n#include <string>\n\nint main() {\n    // --- 1. SETUP: Create a variable and a pointer to it ---\n\n    // This is our \"house\". It's a normal variable holding the value 100.\n    int score = 100;\n\n    // This is our \"contact entry\". \n    // 'int*' means \"this is a pointer that will hold the address of an integer\".\n    // We initialize it to nullptr, which means it's not pointing to anything yet.\n    int* scorePtr = nullptr;\n\n    // Now, let's get the address of 'score' and store it in our pointer.\n    // The '&' operator means \"give me the memory address of\".\n    scorePtr = &score;\n\n    // --- 2. DEMONSTRATION: Accessing data ---\n\n    std::cout << \"--- Accessing Data ---\" << std::endl;\n    // Print the value of the original variable directly.\n    std::cout << \"Direct value of 'score':\\t\\t\" << score << std::endl;\n\n    // Print the value the pointer is pointing to.\n    // The '*' operator here means \"dereference\". It says \"go to the address\n    // stored in scorePtr and get the value that lives there\".\n    std::cout << \"Value via pointer (*scorePtr):\\t\\t\" << *scorePtr << std::endl;\n\n    std::cout << \"\\n--- Viewing Addresses ---\" << std::endl;\n    // Print the memory address of the original variable.\n    std::cout << \"Memory address of 'score' (&score):\\t\" << &score << std::endl;\n\n    // Print the value of the pointer itself. Notice it's the same address!\n    std::cout << \"Value of the pointer (scorePtr):\\t\" << scorePtr << std::endl;\n\n    // --- 3. MODIFICATION: Changing data through the pointer ---\n\n    std::cout << \"\\n--- Modifying Data via Pointer ---\" << std::endl;\n    std::cout << \"Original score is: \" << score << std::endl;\n\n    // Use the dereference operator '*' to change the value AT the address.\n    // This is like sending a command to the house using its address.\n    std::cout << \"Executing: *scorePtr = 250;\" << std::endl;\n    *scorePtr = 250;\n\n    // Now, check the original variable. It has been changed!\n    std::cout << \"The value of 'score' is now:\\t\\t\" << score << std::endl;\n\n    return 0;\n}",
                    "explanation": "The Core Concept: What is a Pointer?\n\nAt its most basic level, a pointer is a variable that doesn't hold data, but holds a memory address.\n\nThe Best Analogy: A Contact in Your Phone\n\nImagine you have a friend named Alex.\n\nAlex himself is the actual data. He has a name, an age, etc.\nA regular variable is like having Alex in the room with you: string friend = \"Alex\";\n\nNow, imagine you save Alex's home address in your phone's contact list under the name \"AlexsHouse\".\n\nThe contact entry \"AlexsHouse\" is the pointer.\nThe address written inside it (\"123 Maple St.\") is the value of the pointer.\nThe contact entry itself is not Alex, but it tells you exactly where to find him.\n\nIf you want to send Alex a package, you don't put Alex himself in the mail. You use the address from your contact list (the pointer) to tell the mail service where to deliver the package. This is what pointers do for your program.\n\nWhy Bother Using Pointers?\n\nIn C++, pointers are fundamental for two main reasons:\n\nEfficiency: Imagine you have a huge, complex object. If you want a function to work with it, making a full copy is slow and wastes memory. Instead, you can just pass a pointer (the small \"address\" in your contacts). The function can then use that address to work with the one and only original object.\n\nDynamic Memory: Sometimes you don't know how many objects you'll need when you write your program. Pointers allow you to request new memory while the program is running (on the \"heap\") and store the address of that new memory in a pointer.\n",
                    "output": "--- Accessing Data ---\nDirect value of 'score':              100\nValue via pointer (*scorePtr):        100\n\n--- Viewing Addresses ---\nMemory address of 'score' (&score):   0x7ffc1b3f6a2c\nValue of the pointer (scorePtr):      0x7ffc1b3f6a2c\n\n--- Modifying Data via Pointer ---\nOriginal score is: 100\nExecuting: *scorePtr = 250;\nThe value of 'score' is now:          250"
                },
                "description": "At most basic level pointer is a varable that doesn't hold data but holds memory address",
                "implementation": {
                    "code": "#include <Arduino.h>\n#include <Wire.h>\n#include <string>\n#include <Adafruit_GFX.h>\n#include <Adafruit_SSD1306.h>\n\n// =================================================================\n// CONCEPT: POINTERS\n// A pointer is a variable that holds a memory address. We can use it\n// to dynamically choose which object's function to call.\n// =================================================================\n\n// --- Define an \"Interface\" using an Abstract Base Class ---\n// This blueprint says that any \"Blinker\" object MUST have a blink() method.\nclass Blinker {\npublic:\n    virtual void initialize() = 0; // Pure virtual function\n    virtual void blink() = 0;      // Pure virtual function\n};\n\n// --- First Implementation: Blinks the on-board LED ---\nclass LedBlinker : public Blinker {\npublic:\n    void initialize() override {\n        pinMode(LED_BUILTIN, OUTPUT);\n        Serial.println(\"On-board LED initialized.\");\n    }\n    \n    void blink() override {\n        Serial.println(\"Blinking on-board LED...\");\n        digitalWrite(LED_BUILTIN, HIGH);\n        delay(500);\n        digitalWrite(LED_BUILTIN, LOW);\n        delay(500);\n    }\n};\n\n// --- Second Implementation: Blinks a message on the OLED ---\nclass OledBlinker : public Blinker {\nprivate:\n    Adafruit_SSD1306 display;\n\npublic:\n    OledBlinker() : display(128, 64, &Wire, -1) {}\n\n    void initialize() override {\n        if (!display.begin(SSD1306_SWITCHCAPVCC, 0x3C)) {\n             Serial.println(\"OLED Failed!\");\n             for(;;);\n        }\n        Serial.println(\"OLED Display initialized.\");\n    }\n\n    void blink() override {\n        Serial.println(\"Blinking message on OLED...\");\n        display.clearDisplay();\n        display.setTextSize(2);\n        display.setTextColor(WHITE);\n        display.setCursor(20, 10);\n        display.println(\"BLINK!\");\n        display.display();\n        delay(500);\n        \n        display.clearDisplay();\n        display.display();\n        delay(500);\n    }\n};\n\n// --- Global Objects ---\nLedBlinker myLed;\nOledBlinker myOled;\n\n// This is our POINTER. It's a variable that can hold the address\n// of ANY object that is a \"Blinker\" (i.e., LedBlinker or OledBlinker).\nBlinker* currentBlinkerPtr = nullptr;\n\n\nvoid setup() {\n    Serial.begin(115200);\n    Wire.begin();\n    delay(1000);\n    Serial.println(\"--- Program Start: Pointers ---\");\n    \n    myLed.initialize();\n    myOled.initialize();\n\n    // --- Using the Pointer ---\n    // First, let's make the pointer hold the ADDRESS of the myLed object.\n    Serial.println(\"\\nSetting pointer to the LED Blinker...\");\n    currentBlinkerPtr = &myLed;\n}\n\nvoid loop() {\n    // This is the magic of pointers. We don't need to know if we are\n    // controlling the LED or the OLED. We just tell the pointer:\n    // \"Go to the address you're holding and call the blink() method on whatever object you find there.\"\n    currentBlinkerPtr->blink();\n    \n    // Every 5 blinks, we will SWITCH what the pointer is pointing to.\n    static int blinkCount = 0;\n    blinkCount++;\n    if (blinkCount % 5 == 0) {\n        // Check what the pointer is currently pointing to\n        if (currentBlinkerPtr == &myLed) {\n            // If it's pointing to the LED, switch it to point to the OLED\n            Serial.println(\"\\n>>> SWITCHING pointer to OLED Blinker <<<\");\n            currentBlinkerPtr = &myOled;\n        } else {\n            // If it's pointing to the OLED, switch it back to the LED\n            Serial.println(\"\\n>>> SWITCHING pointer back to LED Blinker <<<\");\n            currentBlinkerPtr = &myLed;\n        }\n    }\n}",
                    "explanation": "Pointers\n\nGoal: To teach how a pointer (a variable holding a memory address) can be used to manage and control a hardware object.\n\nConcept Explained: This program creates a Robot class that does not contain a display object directly. Instead, it contains a pointer to a display object (Adafruit_SSD1306* displayPtr). This means the robot doesn't own the display, it's just given its address so it knows where to send commands. The & operator gets the display's address. The special arrow operator (->) is then used to call methods on the object that the pointer points to. This design pattern (Dependency Injection) makes the Robot class more flexible."
                }
            },
            "Strings": {
                "concept": {
                    "code": "#include <iostream>\n#include <string> // Include the string library\n\nint main() {\n    // Create two string objects.\n    std::string robotName = \"R2-D2\";\n    std::string designation = \"Astromech Droid\";\n\n    // You can combine strings using the '+' operator.\n    std::string fullTitle = robotName + \" - \" + designation;\n\n    std::cout << \"Robot's Name: \" << robotName << std::endl;\n    std::cout << \"Full Title: \" << fullTitle << std::endl;\n\n    // The string object knows its own length.\n    std::cout << \"Length of the title: \" << fullTitle.length() << \" characters.\" << std::endl;\n\n    return 0;\n}",
                    "explanation": "Strings\n\nHigh-Level Concept: Strings are specialized objects for storing and manipulating text.\n\nAnalogy:\nA std::string is like a modern word-processed document on a computer, not just a simple sequence of letters. It's an object that knows its own length, can easily add text to the end, find and replace words, and handles all the complex memory management for the text automatically.\n\nHow it Works in Code:\n\n#include <string> is required to use the std::string class.\n\nstd::string robotName = \"R2-D2\"; creates a string object and initializes it with the text \"R2-D2\".\n\nYou can \"add\" strings together using the + operator, which concatenates them (joins them end-to-end).\n\nPrinting a string with std::cout is straightforward and handles any length of text.",
                    "output": "Robot's Name: R2-D2\nFull Title: R2-D2 - Astromech Droid\nLength of the title: 27 characters."
                },
                "description": "Strings are specialized objects for storing and manipulating text",
                "implementation": {
                    "code": "#include <Arduino.h>\n#include <Wire.h>\n#include <string> // Required to use the std::string class\n#include <VL53L0X.h>\n#include <Adafruit_GFX.h>\n#include <Adafruit_SSD1306.h>\n\n// --- Hardware Objects ---\nAdafruit_SSD1306 display(128, 64, &Wire, -1);\nVL53L0X sensor;\n\n// =================================================================\n// CONCEPT: STRINGS\n// =================================================================\n\nvoid setup() {\n    Serial.begin(115200);\n    Wire.begin();\n    if (!display.begin(SSD1306_SWITCHCAPVCC, 0x3C)) { for(;;); }\n    sensor.setTimeout(500);\n    if (!sensor.init()) { while(1); }\n    sensor.startContinuous();\n    \n    Serial.println(\"--- Program Start: Strings ---\");\n}\n\nvoid loop() {\n    // 1. Get data from the sensor.\n    int distance = sensor.readRangeContinuousMillimeters();\n\n    // 2. Create String objects to build a message.\n    std::string label = \"Dist: \";\n    std::string value = std::to_string(distance); // Convert the number to a string\n    std::string units = \" mm\";\n\n    // 3. Manipulate Strings: Join them together with the '+' operator.\n    std::string fullMessage = label + value + units;\n\n    // 4. Display the final string on the OLED.\n    // .c_str() converts the string object to a format the display library understands.\n    display.clearDisplay();\n    display.setTextSize(2);\n    display.setTextColor(WHITE);\n    display.setCursor(0, 10);\n    display.println(fullMessage.c_str());\n    display.display();\n\n    // Also print to Serial for comparison\n    Serial.println(fullMessage.c_str()); // <<< THIS LINE IS NOW CORRECTED\n\n    delay(100);\n}",
                    "explanation": "Strings\n\nGoal: To teach how to use the std::string object to build and display dynamic status messages on the robot's OLED screen.\n\nConcept Explained: A String is a specialized object for text. This program reads the distance sensor. Instead of just printing the number, it converts the number to a std::string object. It then uses the + operator to join this string with other strings to build a complete, readable message (e.g., \"Dist: 150 mm\"). This final message is then displayed on the OLED, demonstrating how strings are used to create dynamic, user-friendly feedback."
                }
            }
        }
    },
    "Robotics": {
        "levels": {}
    }
}