{
    "Basic C++": {
        "levels": {
            "First C++ Program": {
                "description": "Hello World it swas first ever written program",
                "concept": {
                    "explanation": "Code Explanation:\n#include <iostream>: Prepares your program to use tools for input and output.\n\nint main(): Defines the main function where the program begins. int means it will return an integer value when it's done.\n\nstd::cout: This is the \"standard character output\" stream, which usually means the console or terminal. The std:: part means cout is \n\nlocated in the standard (std) namespace.\n\n<<: The stream insertion operator. It \"inserts\" the data on its right into the stream on its left.\n\nstd::endl: Inserts a newline character, so the next output will start on a new line.\n\nreturn 0;: This is a status code sent to the operating system. A return value of 0 conventionally means \"everything went okay.\"",
                    "code": "// Include the Input/Output Stream library\n#include <iostream>\n\n// All C++ programs start execution in the main function\nint main() {\n    // std::cout sends text to the console.\n    // << is the stream insertion operator.\n    // \"Hello, World!\" is the text to be printed.\n    // std::endl adds a new line and flushes the output.\n    std.cout << \"Hello, World!\" << std::endl;\n\n    // Return 0 to indicate that the program finished successfully.\n    return 0;\n}",
                    "output": "Hello, World!"
                },
                "implementation": {
                    "explanation": "Concept: This is the \"Hello, World!\" of embedded systems. It teaches the basic structure of an Arduino/PlatformIO program (setup() and loop()) by initializing the OLED screen and displaying a static message.\nExplanation: The setup() function runs only once at the start. We use it to initialize the OLED display. We clear its memory, set the text size and color, position the cursor, and write \"Hello Robot!\". The display() command pushes this information to the screen. The loop() function is empty because we don't need to update the screen after the initial message.",
                    "code": "// <<< FIX: Include the main Arduino header FIRST >>>\n// This ensures all core definitions (like Wire) are loaded before any other library.\n#include <Arduino.h>\n\n// Now include the other libraries\n#include <Wire.h>\n#include <Adafruit_GFX.h>\n#include <Adafruit_SSD1306.h>\n\n#define SCREEN_WIDTH 128\n#define SCREEN_HEIGHT 64\n\n// Create the display object globally. This is safe now because Arduino.h is included first.\nAdafruit_SSD1306 display(SCREEN_WIDTH, SCREEN_HEIGHT, &Wire, -1);\n\nvoid setup() {\n  // Start I2C communication (required for the OLED)\n  Wire.begin();\n\n  // Initialize the display\n  if (!display.begin(SSD1306_SWITCHCAPVCC, 0x3C)) {\n    for (;;); // If it fails, halt the program\n  }\n\n  // --- Main Actions ---\n  display.clearDisplay();\n  display.setTextSize(2);\n  display.setTextColor(WHITE);\n  display.setCursor(10, 10);\n  display.println(\"Hello\");\n  display.println(\" Robot!\");\n  display.display(); // Push the text to the screen\n}\n\nvoid loop() {\n  // The screen is static, so nothing needs to be repeated here.\n}"
                }
            },
            "Variables & Datatypes": {
                "description": "This program demonstrates how to declare and use variables of different fundamental types",
                "concept": {
                    "explanation": "This program demonstrates how to declare and use variables of different fundamental types.\n\nA variable is a named storage location for data.\n\nint age = 25;: Declares an integer variable age to hold whole numbers.\n\ndouble temperature = 98.6;: Declares a double-precision floating-point variable temperature for numbers with decimal points.\n\nchar grade = 'A';: Declares a character variable grade to hold a single character (enclosed in single quotes).\n\nbool isStudent = true;: Declares a boolean variable isStudent which can only be true or false. When printed, true is output as 1 and \nfalse as 0.\n\nstd::string name = \"John Doe\";: Declares a string variable name for holding text (enclosed in double quotes). You must #include \n\n<string> to use it.\n",
                    "code": "#include <iostream>\n#include <string> // Required for using the string data type\n\nint main() {\n    int age = 25;\n    double temperature = 98.6;\n    char grade = 'A';\n    bool isStudent = true;\n    std::string name = \"John Doe\";\n\n    std::cout << \"Name: \" << name << std::endl;\n    std::cout << \"Age: \" << age << std::endl;\n    std::cout << \"Is a student? \" << isStudent << std::endl; // Prints 1 for true\n\n    return 0;\n}",
                    "output": "Name: John Doe\nAge: 25\nIs a student? 1"
                },
                "implementation": {
                    "explanation": "Concept: This level introduces variables as named containers for data. We use an int (integer) variable to store the distance from the sensor and a bool (true/false) variable to track the sensor's status, demonstrating how data can be stored, updated, and displayed.\nExplanation: We declare a global variable distance_mm of type int. In the loop(), we read the sensor's value and store the result in this variable. We then clear the OLED and print the text \"Dist:\" followed by the value currently stored inside distance_mm. This shows how a variable's content can change with each loop.\n",
                    "code": "#include <Arduino.h>\n#include <Wire.h>\n#include <VL53L0X.h> // Include the Pololu sensor library\n#include <Adafruit_GFX.h>\n#include <Adafruit_SSD1306.h>\n\n#define SCREEN_WIDTH 128\n#define SCREEN_HEIGHT 64\n\nVL53L0X sensor;\nAdafruit_SSD1306 display(SCREEN_WIDTH, SCREEN_HEIGHT, &Wire, -1);\n\n// A variable of datatype 'int' to store a whole number\nint distance_mm = 0; \n// A variable of datatype 'bool' to store a true/false value\nbool sensor_ok = false;\n\nvoid setup() {\n  Wire.begin();\n  display.begin(SSD1306_SWITCHCAPVCC, 0x3C);\n\n  // Initialize the sensor and store the result in our boolean variable\n  sensor.setTimeout(500);\n  if (sensor.init()) {\n    sensor_ok = true;\n    sensor.startContinuous();\n  }\n  \n  // Display status based on the boolean variable's value\n  display.clearDisplay();\n  display.setTextSize(1);\n  display.setTextColor(WHITE);\n  display.setCursor(0, 0);\n  if (sensor_ok) {\n    display.println(\"Sensor... OK\");\n  } else {\n    display.println(\"Sensor... FAILED\");\n  }\n  display.display();\n  delay(2000);\n}\n\nvoid loop() {\n  // Store the latest sensor reading in our integer variable\n  distance_mm = sensor.readRangeContinuousMillimeters();\n\n  // Display the content of the variable on the screen\n  display.clearDisplay();\n  display.setTextSize(2);\n  display.setCursor(0, 0);\n  display.print(\"Dist:\");\n  display.setCursor(0, 20);\n  display.print(distance_mm); // This prints the number stored in the variable\n  display.print(\" mm\");\n  display.display();\n  \n  delay(100);\n}"
                }
            },
            "Basic Input/Output (I/O)": {
                "description": "This program interacts with the user by reading their input from the console",
                "concept": {
                    "explanation": "Explanation\n\nThis program interacts with the user by reading their input from the console.\n\nstd::cin is the standard character input stream (the keyboard).\n\nstd::getline(std::cin, userName);: This is the recommended way to read a full line of text, including spaces. It reads from std::cin and \n\nstores the result in the userName variable.\n\nstd::cin >> userAge;: The stream extraction operator >> reads data from the input and stores it in the variable. It stops reading when \n\nit encounters whitespace (like a space or newline), making it suitable for single words or numbers.\n",
                    "code": "#include <iostream>\n#include <string>\n\nint main() {\n    int userAge;\n    std::string userName;\n\n    std::cout << \"Please enter your name: \";\n    std::getline(std::cin, userName);\n\n    std::cout << \"Please enter your age: \";\n    std::cin >> userAge;\n\n    std::cout << \"\\nHello, \" << userName << \"!\" << std::endl;\n    std::cout << \"You are \" << userAge << \" years old.\" << std::endl;\n\n    return 0;\n}",
                    "output": "Please enter your name: Jane Smith\nPlease enter your age: 30\n\nHello, Jane Smith!\nYou are 30 years old."
                },
                "implementation": {
                    "explanation": "Concept: This level focuses on controlling the motors. It teaches how to configure the ESP32's pins as OUTPUTs using pinMode() and how to send signals to the motor driver with digitalWrite() (for direction) and analogWrite() (for speed).\nExplanation: We define all six motor control pins. In setup(), we declare them all as outputs. In the loop(), we create a simple sequence: move forward, stop, move backward, stop. We use digitalWrite() to set the IN pins to control direction and analogWrite() on the ENA/ENB pins to control the speed with a PWM signal.",
                    "code": "#include <Arduino.h>\n\n// Pin Definitions matching your wiring\n#define ENA 25\n#define IN1 14\n#define IN2 18\n#define ENB 26\n#define IN3 12\n#define IN4 5\n\nvoid setup() {\n  // Set all motor control pins to OUTPUT mode\n  pinMode(ENA, OUTPUT);\n  pinMode(IN1, OUTPUT);\n  pinMode(IN2, OUTPUT);\n  pinMode(ENB, OUTPUT);\n  pinMode(IN3, OUTPUT);\n  pinMode(IN4, OUTPUT);\n}\n\nvoid loop() {\n  // --- Move Forward ---\n  digitalWrite(IN1, HIGH);\n  digitalWrite(IN2, LOW);\n  digitalWrite(IN3, HIGH);\n  digitalWrite(IN4, LOW);\n  analogWrite(ENA, 200); // Set speed (0-255)\n  analogWrite(ENB, 200);\n  delay(2000);\n\n  // --- Stop ---\n  analogWrite(ENA, 0); // Speed = 0\n  analogWrite(ENB, 0);\n  delay(2000);\n\n  // --- Move Backward ---\n  digitalWrite(IN1, LOW);\n  digitalWrite(IN2, HIGH);\n  digitalWrite(IN3, LOW);\n  digitalWrite(IN4, HIGH);\n  analogWrite(ENA, 200);\n  analogWrite(ENB, 200);\n  delay(2000);\n\n  // --- Stop ---\n  analogWrite(ENA, 0);\n  analogWrite(ENB, 0);\n  delay(2000);\n}"
                }
            },
            "Conditionals": {
                "description": "This program makes a decision based on users input",
                "concept": {
                    "explanation": "Explanation\n\nThis program makes a decision based on the user's input.\n\nThe if statement checks a condition. If score >= 90 is true, its code block is executed, and the rest of the chain is skipped.\n\nIf the if condition is false, the program proceeds to the else if statement and checks its condition.\n\nThe else block is a catch-all. It executes only if all the preceding if and else if conditions in the chain were false. This creates a branching path in the program's logic.\n",
                    "code": "#include <iostream>\n\nint main() {\n    int score;\n    std::cout << \"Enter your test score (0-100): \";\n    std::cin >> score;\n\n    if (score >= 90) {\n        std::cout << \"You got an A!\" << std::endl;\n    }\n    else if (score >= 80) {\n        std::cout << \"You got a B.\" << std::endl;\n    }\n    else {\n        std::cout << \"You need to study more.\" << std::endl;\n    }\n\n    return 0;\n}",
                    "output": "Enter your test score (0-100): 85\nYou got a B."
                },
                "implementation": {
                    "explanation": "Concept: This is where the robot gets \"smart.\" if-else statements allow the robot to make decisions. It checks the sensor reading and executes different functions based on the result.\nExplanation: The loop() now constantly reads the distance sensor. It uses an if statement to check if (distance < 200). If this condition is true (an obstacle is close), it runs the code inside the if block (stop and turn). If the condition is false, it runs the code inside the else block (move forward). This creates the core obstacle-avoiding behavior.",
                    "code": "#include <Arduino.h>\n#include <Wire.h>\n#include <VL53L0X.h>\n\n// Pins and motor functions from previous level\n#define ENA 25\n#define IN1 14\n#define IN2 18\n#define ENB 26\n#define IN3 12\n#define IN4 5\n\nVL53L0X sensor;\n\nvoid moveForward(int speed) { digitalWrite(IN1, HIGH); digitalWrite(IN2, LOW); digitalWrite(IN3, HIGH); digitalWrite(IN4, LOW); analogWrite(ENA, speed); analogWrite(ENB, speed); }\nvoid moveStop() { analogWrite(ENA, 0); analogWrite(ENB, 0); }\nvoid turnRight(int speed) { digitalWrite(IN1, HIGH); digitalWrite(IN2, LOW); digitalWrite(IN3, LOW); digitalWrite(IN4, HIGH); analogWrite(ENA, speed); analogWrite(ENB, speed); }\n\nvoid setup() {\n  Wire.begin();\n  pinMode(ENA, OUTPUT); pinMode(IN1, OUTPUT); pinMode(IN2, OUTPUT);\n  pinMode(ENB, OUTPUT); pinMode(IN3, OUTPUT); pinMode(IN4, OUTPUT);\n  sensor.setTimeout(500);\n  if (!sensor.init()) { while (1) {} }\n  sensor.startContinuous();\n}\n\nvoid loop() {\n  // SENSE: Read the distance\n  int distance = sensor.readRangeContinuousMillimeters();\n  bool isValidReading = !sensor.timeoutOccurred();\n\n  // THINK: Make a decision with an if-else statement\n  if (distance < 200 && isValidReading) {\n    // ACT: Obstacle is close, so turn\n    turnRight(180);\n    delay(500); // Turn for a fixed duration\n  } else {\n    // ACT: Path is clear, so move forward\n    moveForward(200);\n  }\n}"
                }
            },
            "Loops": {
                "description": "This program demonstrates the two most common types of loops",
                "concept": {
                    "explanation": "Explanation\n\nThis program demonstrates the two most common types of loops.\n\nA for loop is ideal when you know exactly how many times you want to repeat an action. The statement for (int i = 1; i <= 4; ++i) does three things: 1) initializes i to 1, 2) sets the condition to loop as long as i is less than or equal to 4, and 3) increments i after each loop iteration.\n\nA while loop is used to repeat as long as a condition remains true. The loop checks while (countdown > 0) before each iteration. The value of countdown must be changed inside the loop to prevent it from running forever (an infinite loop).",
                    "code": "#include <iostream>\n\nint main() {\n    // --- for loop ---\n    std::cout << \"--- For Loop ---\" << std::endl;\n    for (int i = 1; i <= 4; ++i) {\n        std::cout << \"Iteration number \" << i << std::endl;\n    }\n\n    // --- while loop ---\n    std::cout << \"\\n--- While Loop ---\" << std::endl;\n    int countdown = 3;\n    while (countdown > 0) {\n        std::cout << countdown << \"...\" << std::endl;\n        countdown = countdown - 1; // or countdown--;\n    }\n    std::cout << \"Lift off!\" << std::endl;\n\n    return 0;\n}",
                    "output": "--- For Loop ---\nIteration number 1\nIteration number 2\nIteration number 3\nIteration number 4\n\n--- While Loop ---\n3...\n2...\n1...\nLift off!"
                },
                "implementation": {
                    "explanation": "Concept: This final program integrates all previous concepts and adds a for loop to create a more refined behavior. The for loop is used to repeat an action a specific number of times.\nExplanation: This version combines everything: sensor, motors, and OLED. When an obstacle is detected, the robot performs a more complex escape maneuver (back up, then turn). A for loop is used to blink a status message on the OLED screen multiple times while the robot is turning, providing clear visual feedback. This demonstrates a practical use for a loop inside the main loop().",
                    "code": "#include <Arduino.h>\n#include <Wire.h>\n#include <VL53L0X.h>\n#include <Adafruit_GFX.h>\n#include <Adafruit_SSD1306.h>\n\n// Pin Definitions\n#define ENA 25\n#define IN1 14\n#define IN2 18\n#define ENB 26\n#define IN3 12\n#define IN4 5\n\n// Behavior Constants\n#define OBSTACLE_THRESHOLD 200\n#define NORMAL_SPEED 200\n#define TURN_SPEED 180\n\n// Hardware Objects\nVL53L0X sensor;\nAdafruit_SSD1306 display(128, 64, &Wire, -1);\n\n// Robot Action Functions\nvoid moveForward(int speed) { digitalWrite(IN1, HIGH); digitalWrite(IN2, LOW); digitalWrite(IN3, HIGH); digitalWrite(IN4, LOW); analogWrite(ENA, speed); analogWrite(ENB, speed); }\nvoid moveBackward(int speed) { digitalWrite(IN1, LOW); digitalWrite(IN2, HIGH); digitalWrite(IN3, LOW); digitalWrite(IN4, HIGH); analogWrite(ENA, speed); analogWrite(ENB, speed); }\nvoid turnRight(int speed) { digitalWrite(IN1, HIGH); digitalWrite(IN2, LOW); digitalWrite(IN3, LOW); digitalWrite(IN4, HIGH); analogWrite(ENA, speed); analogWrite(ENB, speed); }\nvoid moveStop() { analogWrite(ENA, 0); analogWrite(ENB, 0); }\n\nvoid setup() {\n  Wire.begin();\n  pinMode(ENA, OUTPUT); pinMode(IN1, OUTPUT); pinMode(IN2, OUTPUT);\n  pinMode(ENB, OUTPUT); pinMode(IN3, OUTPUT); pinMode(IN4, OUTPUT);\n  if (!display.begin(SSD1306_SWITCHCAPVCC, 0x3C)) { for(;;); }\n  sensor.setTimeout(500);\n  if (!sensor.init()) { while (1); }\n  sensor.startContinuous();\n}\n\nvoid loop() {\n  int distance = sensor.readRangeContinuousMillimeters();\n  bool isValidReading = !sensor.timeoutOccurred();\n\n  display.clearDisplay();\n  display.setTextColor(WHITE);\n  display.setTextSize(2);\n  display.setCursor(0, 0);\n  display.print(\"Dist: \");\n  display.print(distance);\n\n  if (distance < OBSTACLE_THRESHOLD && isValidReading) {\n    display.setCursor(0, 20);\n    display.print(\"OBSTACLE!\");\n    display.display();\n    \n    // Escape Maneuver\n    moveBackward(NORMAL_SPEED);\n    delay(300);\n    turnRight(TURN_SPEED);\n    \n    // Use a 'for' loop to blink a turning indicator\n    display.setTextSize(1);\n    for (int i = 0; i < 4; i++) {\n        display.setCursor(0, 40);\n        display.print(\"Turning...  \");\n        display.display();\n        delay(100);\n        display.setCursor(0, 40);\n        display.print(\"Turning... *\");\n        display.display();\n        delay(100);\n    } // The turn lasts for 4 * 200ms = 800ms\n    moveStop();\n    delay(100);\n  } else {\n    display.setCursor(0, 20);\n    display.print(\"All Clear\");\n    moveForward(NORMAL_SPEED);\n    display.display();\n  }\n  \n  delay(50);\n}"
                }
            },
            "Functions": {
                "description": "This program defines and uses a function to make the code more organized and reusable",
                "concept": {
                    "explanation": "This program defines and uses a function to make the code more organized and reusable.\n\nFunction Declaration: int add(int num1, int num2); is a prototype that tells the compiler about the function before main uses it. It \nspecifies the function's name, the data types of its parameters (int, int), and its return type (int).\n\nFunction Call: In main, the line int sum = add(a, b); executes the function. The values of a and b are passed as arguments. The function's return value is captured in the sum variable.\n\nFunction Definition: This is the actual block of code that runs when the function is called. It takes the arguments, performs the addition, and uses the return keyword to send the result back to the caller.\n",
                    "code": "#include <iostream>\n\n// Function Declaration (Prototype)\nint add(int num1, int num2);\n\nint main() {\n    int a = 5;\n    int b = 7;\n\n    // Function Call\n    int sum = add(a, b);\n\n    std::cout << \"The sum is \" << sum << std::endl;\n    return 0;\n}\n\n// Function Definition\nint add(int num1, int num2) {\n    return num1 + num2;\n}```\n\n",
                    "output": "#### Expected Output\n```text\nThe sum is 12"
                },
                "implementation": {
                    "explanation": "Concept: Making code cleaner and reusable by creating named blocks of code called functions. This avoids repetition and makes the main program logic much easier to read.\nExplanation: We take the repetitive blocks of digitalWrite and analogWrite calls from Level 3 and wrap them in functions like moveForward(int speed). Now, the loop() is very simple and readable. To make the robot move forward, we just call moveForward(200);. The int speed parameter makes the function flexible.",
                    "code": "#include <Arduino.h>\n\n// Pin Definitions\n#define ENA 25\n#define IN1 14\n#define IN2 18\n#define ENB 26\n#define IN3 12\n#define IN4 5\n\n// A function to move the robot forward at a given speed\nvoid moveForward(int speed) {\n  digitalWrite(IN1, HIGH);\n  digitalWrite(IN2, LOW);\n  digitalWrite(IN3, HIGH);\n  digitalWrite(IN4, LOW);\n  analogWrite(ENA, speed);\n  analogWrite(ENB, speed);\n}\n\n// A function to stop both motors\nvoid moveStop() {\n  analogWrite(ENA, 0);\n  analogWrite(ENB, 0);\n}\n\n// A function to pivot the robot to the right\nvoid turnRight(int speed) {\n  digitalWrite(IN1, HIGH); // Left motor forward\n  digitalWrite(IN2, LOW);\n  digitalWrite(IN3, LOW);  // Right motor backward\n  digitalWrite(IN4, HIGH);\n  analogWrite(ENA, speed);\n  analogWrite(ENB, speed);\n}\n\nvoid setup() {\n  pinMode(ENA, OUTPUT); pinMode(IN1, OUTPUT); pinMode(IN2, OUTPUT);\n  pinMode(ENB, OUTPUT); pinMode(IN3, OUTPUT); pinMode(IN4, OUTPUT);\n}\n\nvoid loop() {\n  // The loop is now much easier to read by calling functions\n  moveForward(200);\n  delay(2000);\n\n  moveStop();\n  delay(1000);\n\n  turnRight(180);\n  delay(1000);\n\n  moveStop();\n  delay(2000);\n}"
                }
            }
        }
    },
    "OPP": {
        "levels": {
            "Class and Objects": {
                "description": "A class is a blueprint; an object is the actual thing built from that blueprint.",
                "concept": {
                    "explanation": "Classes and Objects\nHigh-Level Concept: A class is a blueprint; an object is the actual thing built from that blueprint.\n\nAnalogy:\nThink of an architectural blueprint for a house. The blueprint is the Class. It defines what all houses of its type must have: doors, windows, a foundation, etc. It also defines what they can do: doors can open, windows can slide.\n\nThe actual houses built from this blueprint are the Objects. House A and House B are both objects of the House class. They share the same structure but are independent: House A can be painted blue, while House B is red. Opening the door of House A does not \nopen the door of House B.\n\n\nHow it Works in Code:\n\n\tThe class Vector2D { ... }; block is the blueprint.\n\n\tThe float x; float y; inside are the attributes, the properties defined in the blueprint.\n\n\tThe Vector2D(float startX, float startY) is the constructor. This is like the part of the blueprint that says, \"When you start               building, you must specify the initial coordinates.\"\n\n\tVector2D playerPosition(10.0f, 20.0f); is the act of construction. You are creating a specific, real Vector2D object n\tamed playerPosition. This object now has its own x and y variables set to 10 and 20.\n",
                    "code": "#include <iostream>\n\n// The blueprint for a 2D vector.\nclass Vector2D {\npublic: // 'public' means these can be accessed from outside the class.\n    // Attributes: Every Vector2D will have its own x and y.\n    float x;\n    float y;\n\n    // Constructor: This method is called automatically when a new object is created.\n    // Its job is to initialize the object's attributes.\n    Vector2D(float startX, float startY) {\n        x = startX;\n        y = startY;\n        std::cout << \"[Constructor Called] Vector2D object created.\" << std::endl;\n    }\n\n    // Method: A function that belongs to the class.\n    void print() {\n        std::cout << \"(\" << x << \", \" << y << \")\" << std::endl;\n    }\n};\n\nint main() {\n    // We are now creating two distinct OBJECTS from the Vector2D CLASS.\n    Vector2D playerPosition(10.0f, 20.0f);\n    Vector2D enemyVelocity(-5.0f, 0.0f);\n\n    std::cout << \"\\nPlayer Position is an object with its own data: \";\n    playerPosition.print(); // Calls the print() method belonging to this object.\n\n    std::cout << \"Enemy Velocity is a separate object with its own data: \";\n    enemyVelocity.print(); // Calls the print() method on a different object.\n\n    return 0;\n}",
                    "output": "[Constructor Called] Vector2D object created.\n[Constructor Called] Vector2D object created.\n\nPlayer Position is an object with its own data: (10, 20)\nEnemy Velocity is a separate object with its own data: (-5, 0)"
                },
                "implementation": {
                    "explanation": "Classes and Objects\n\nGoal: To teach the concept of a class as a blueprint for your robot and an object as the working instance that controls the hardware.\n\nConcept Explained: We define a Robot Class (the blueprint). This blueprint states that every robot must have motor pins, a sensor, a display, and the ability to initialize() its systems and reportStatus(). In the global scope, we create a single, tangible Object named myBot from this blueprint. The setup() and loop() functions then command this single object to perform actions, and the object uses its internal hardware objects to interact with the real world.",
                    "code": "#include <Arduino.h>\n#include <Wire.h>\n#include <VL53L0X.h>\n#include <Adafruit_GFX.h>\n#include <Adafruit_SSD1306.h>\n\n// --- Pin Definitions ---\n#define ENA 25\n#define IN1 14\n#define IN2 18\n#define ENB 26\n#define IN3 12\n#define IN4 5\n\n// =================================================================\n// CONCEPT: CLASSES AND OBJECTS\n// =================================================================\n\n// The CLASS (the blueprint for our robot)\nclass Robot {\npublic:\n    // Attributes: The hardware components the robot possesses.\n    // These are objects of other classes provided by the libraries.\n    VL53L0X sensor;\n    Adafruit_SSD1306 display;\n\n    // Constructor: Runs when a Robot object is created.\n    Robot() : display(128, 64, &Wire, -1) { // Initialize the display object\n        Serial.println(\"Robot object created in memory.\");\n    }\n\n    // Method: A behavior. This initializes all the hardware.\n    void initializeHardware() {\n        Wire.begin();\n        pinMode(ENA, OUTPUT); pinMode(IN1, OUTPUT); pinMode(IN2, OUTPUT);\n        pinMode(ENB, OUTPUT); pinMode(IN3, OUTPUT); pinMode(IN4, OUTPUT);\n\n        if (!display.begin(SSD1306_SWITCHCAPVCC, 0x3C)) {\n            Serial.println(\"OLED allocation failed\");\n            for(;;);\n        }\n        sensor.setTimeout(500);\n        if (!sensor.init()) {\n            Serial.println(\"Sensor Failed!\");\n            while(1);\n        }\n        sensor.startContinuous();\n        Serial.println(\"All robot hardware initialized.\");\n    }\n\n    // Method: Reports the sensor reading to the OLED display.\n    void reportStatus() {\n        int distance = sensor.readRangeContinuousMillimeters();\n        \n        display.clearDisplay();\n        display.setTextSize(2);\n        display.setTextColor(WHITE);\n        display.setCursor(0, 0);\n        display.print(\"Dist: \");\n        display.print(distance);\n        display.print(\"mm\");\n        display.display();\n    }\n};\n\n// --- Create a global OBJECT from the Robot CLASS ---\nRobot myBot;\n\nvoid setup() {\n    Serial.begin(9600);\n    delay(1000);\n    \n    // Command our object to initialize its hardware.\n    myBot.initializeHardware();\n}\n\nvoid loop() {\n    // Repeatedly command our object to report its status.\n    myBot.reportStatus();\n    delay(100);\n}"
                }
            },
            "Arrays ": {
                "description": "An array is an ordered list used for storing multiple items of the exact same data type. It's the most fundamental way to manage a collection of data .",
                "concept": {
                    "explanation": "Arrays\n\nHigh-Level Concept:\nAn array is an ordered list used for storing multiple items of the exact same data type. It's the most fundamental way to manage a collection of data in almost any programming language.\n\nAnalogy:\nThink of an array as a row of numbered lockers in a hallway.\n\nSame Type: Every locker is designed to hold the same kind of item (e.g., all lockers hold a Vector2D object, you can't put a string in one).\n\nOrdered: The lockers are in a specific, numbered sequence: 0, 1, 2, 3, and so on.\n\nDirect Access: If you know the locker number (the index), you can go directly to it without checking the others. This is called random access and it's very fast.\n\nIndex Starts at 0: Crucially, in programming, the first locker is always numbered 0.",
                    "code": "#include <iostream>\n#include <vector> // Required for using std::vector\n\n// A simple class to store 2D coordinates.\nclass Vector2D {\npublic:\n    float x;\n    float y;\n    Vector2D(float startX, float startY) : x(startX), y(startY) {}\n\n    void print() {\n        std::cout << \"(\" << x << \", \" << y << \")\" << std::endl;\n    }\n};\n\nint main() {\n    // 1. DECLARATION\n    // Create a vector (a dynamic array) that will hold a list of Vector2D objects.\n    // It starts empty.\n    std::vector<Vector2D> pathWaypoints;\n    \n    // 2. ADDING ELEMENTS\n    // Use the .push_back() method to add elements to the end of the array.\n    std::cout << \"Adding waypoints to the path...\" << std::endl;\n    pathWaypoints.push_back(Vector2D(0.0f, 0.0f));   // This becomes element at index 0\n    pathWaypoints.push_back(Vector2D(10.0f, 5.0f));  // This becomes element at index 1\n    pathWaypoints.push_back(Vector2D(12.0f, 15.0f)); // This becomes element at index 2\n\n    std::cout << \"The path now has \" << pathWaypoints.size() << \" waypoints.\" << std::endl;\n\n    std::cout << \"\\n--- Iterating through the array to process the path ---\" << std::endl;\n    \n    // 3. ITERATION and ACCESSING ELEMENTS\n    // A 'for' loop is the perfect tool to visit every element in an array.\n    // The loop runs as long as 'i' is less than the total size of the array.\n    for (int i = 0; i < pathWaypoints.size(); ++i) {\n        std::cout << \"Processing waypoint with index \" << i << \": \";\n        \n        // Use the index 'i' to access the element at that position.\n        pathWaypoints[i].print();\n    }\n    \n    return 0;\n}",
                    "output": "Adding waypoints to the path...\nThe path now has 3 waypoints.\n\n--- Iterating through the array to process the path ---\nProcessing waypoint with index 0: (0, 0)\nProcessing waypoint with index 1: (10, 5)\nProcessing waypoint with index 2: (12, 15)"
                },
                "implementation": {
                    "explanation": "Arrays\n\nGoal: To teach how to use an array (std::vector) to store a sequence of actions for the robot to perform.\n\nConcept Explained: An Array is an ordered list. In this program, we create an array of ints named speedSequence. This array holds a pre-programmed list of motor speeds. The loop() iterates through this array using an index (i). In each iteration, it retrieves a speed value from the array (speedSequence[i]) and commands the motors to run at that speed, demonstrating how an array can be used to choreograph a robot's behavior.\n",
                    "code": "#include <Arduino.h>\n#include <vector> // Required for using std::vector (dynamic array)\n\n// --- Pin Definitions ---\n#define ENA 25\n#define IN1 14\n#define IN2 18\n#define ENB 26\n#define IN3 12\n#define IN4 5\n\n// =================================================================\n// CONCEPT: ARRAYS\n// =================================================================\n\n// 1. Declaration: Create a vector (an array) to hold a list of motor speeds.\nstd::vector<int> speedSequence;\nint currentStep = 0; // An index to track our position in the array\n\nvoid setup() {\n    Serial.begin(115200);\n    delay(1000);\n    Serial.println(\"--- Program Start: Arrays ---\");\n\n    pinMode(ENA, OUTPUT); pinMode(IN1, OUTPUT); pinMode(IN2, OUTPUT);\n    pinMode(ENB, OUTPUT); pinMode(IN3, OUTPUT); pinMode(IN4, OUTPUT);\n\n    // 2. Adding Elements: Populate our array with a sequence of actions.\n    // Positive values = forward speed, Negative = backward, 0 = stop.\n    speedSequence.push_back(150); // Step 0: Move forward slow\n    speedSequence.push_back(255); // Step 1: Move forward fast\n    speedSequence.push_back(0);   // Step 2: Stop\n    speedSequence.push_back(-200);// Step 3: Move backward\n    speedSequence.push_back(0);   // Step 4: Stop\n}\n\nvoid loop() {\n    // 3. Accessing Elements: Get the speed from the array at the current step.\n    int currentSpeed = speedSequence[currentStep];\n\n    Serial.print(\"Executing step \");\n    Serial.print(currentStep);\n    Serial.print(\": Speed = \");\n    Serial.println(currentSpeed);\n\n    if (currentSpeed > 0) {\n        // Move forward\n        digitalWrite(IN1, HIGH); digitalWrite(IN2, LOW);\n        digitalWrite(IN3, HIGH); digitalWrite(IN4, LOW);\n        analogWrite(ENA, currentSpeed); analogWrite(ENB, currentSpeed);\n    } else if (currentSpeed < 0) {\n        // Move backward\n        digitalWrite(IN1, LOW); digitalWrite(IN2, HIGH);\n        digitalWrite(IN3, LOW); digitalWrite(IN4, HIGH);\n        analogWrite(ENA, -currentSpeed); analogWrite(ENB, -currentSpeed);\n    } else {\n        // Stop\n        analogWrite(ENA, 0); analogWrite(ENB, 0);\n    }\n\n    // Move to the next index in the array for the next loop iteration.\n    currentStep++;\n    // If we've reached the end of the array, loop back to the beginning.\n    if (currentStep >= speedSequence.size()) {\n        currentStep = 0;\n        Serial.println(\"--- Sequence restarting ---\");\n    }\n\n    delay(2000); // Hold each action for 2 seconds\n}"
                }
            },
            "Strings": {
                "description": "Strings are specialized objects for storing and manipulating text",
                "concept": {
                    "explanation": "Strings\n\nHigh-Level Concept: Strings are specialized objects for storing and manipulating text.\n\nAnalogy:\nA std::string is like a modern word-processed document on a computer, not just a simple sequence of letters. It's an object that knows its own length, can easily add text to the end, find and replace words, and handles all the complex memory management for the text automatically.\n\nHow it Works in Code:\n\n#include <string> is required to use the std::string class.\n\nstd::string robotName = \"R2-D2\"; creates a string object and initializes it with the text \"R2-D2\".\n\nYou can \"add\" strings together using the + operator, which concatenates them (joins them end-to-end).\n\nPrinting a string with std::cout is straightforward and handles any length of text.",
                    "code": "#include <iostream>\n#include <string> // Include the string library\n\nint main() {\n    // Create two string objects.\n    std::string robotName = \"R2-D2\";\n    std::string designation = \"Astromech Droid\";\n\n    // You can combine strings using the '+' operator.\n    std::string fullTitle = robotName + \" - \" + designation;\n\n    std::cout << \"Robot's Name: \" << robotName << std::endl;\n    std::cout << \"Full Title: \" << fullTitle << std::endl;\n\n    // The string object knows its own length.\n    std::cout << \"Length of the title: \" << fullTitle.length() << \" characters.\" << std::endl;\n\n    return 0;\n}",
                    "output": "Robot's Name: R2-D2\nFull Title: R2-D2 - Astromech Droid\nLength of the title: 27 characters."
                },
                "implementation": {
                    "explanation": "Strings\n\nGoal: To teach how to use the std::string object to build and display dynamic status messages on the robot's OLED screen.\n\nConcept Explained: A String is a specialized object for text. This program reads the distance sensor. Instead of just printing the number, it converts the number to a std::string object. It then uses the + operator to join this string with other strings to build a complete, readable message (e.g., \"Dist: 150 mm\"). This final message is then displayed on the OLED, demonstrating how strings are used to create dynamic, user-friendly feedback.",
                    "code": "#include <Arduino.h>\n#include <Wire.h>\n#include <string> // Required to use the std::string class\n#include <VL53L0X.h>\n#include <Adafruit_GFX.h>\n#include <Adafruit_SSD1306.h>\n\n// --- Hardware Objects ---\nAdafruit_SSD1306 display(128, 64, &Wire, -1);\nVL53L0X sensor;\n\n// =================================================================\n// CONCEPT: STRINGS\n// =================================================================\n\nvoid setup() {\n    Serial.begin(115200);\n    Wire.begin();\n    if (!display.begin(SSD1306_SWITCHCAPVCC, 0x3C)) { for(;;); }\n    sensor.setTimeout(500);\n    if (!sensor.init()) { while(1); }\n    sensor.startContinuous();\n    \n    Serial.println(\"--- Program Start: Strings ---\");\n}\n\nvoid loop() {\n    // 1. Get data from the sensor.\n    int distance = sensor.readRangeContinuousMillimeters();\n\n    // 2. Create String objects to build a message.\n    std::string label = \"Dist: \";\n    std::string value = std::to_string(distance); // Convert the number to a string\n    std::string units = \" mm\";\n\n    // 3. Manipulate Strings: Join them together with the '+' operator.\n    std::string fullMessage = label + value + units;\n\n    // 4. Display the final string on the OLED.\n    // .c_str() converts the string object to a format the display library understands.\n    display.clearDisplay();\n    display.setTextSize(2);\n    display.setTextColor(WHITE);\n    display.setCursor(0, 10);\n    display.println(fullMessage.c_str());\n    display.display();\n\n    // Also print to Serial for comparison\n    Serial.println(fullMessage.c_str()); // <<< THIS LINE IS NOW CORRECTED\n\n    delay(100);\n}"
                }
            },
            "Inheritance": {
                "description": "Resing and extending existing blueprints to create specialized versions",
                "concept": {
                    "explanation": "High-Level Concept: Reusing and extending existing blueprints to create specialized versions.\n\nAnalogy:\n\nThink of vehicles. You could have a base blueprint for a Vehicle (the parent class). It would define that all vehicles have a speed and can startEngine(). From this, you could create a more specific blueprint for a Car (the child class). A Car is a Vehicle, so it automatically inherits speed and startEngine(). It can then add its own properties (like numberOfDoors) and its own methods (like turnOnWipers()).\n\nHow it Works in Code:\n\tclass Robot : public GameObject is the C++ syntax for \"The Robot class is a child of the GameObject class.\"\n\n\tGameObject is the parent (or base) class. Robot is the child (or derived) class.\n\n\tThe Robot constructor Robot(...) : GameObject(...) is crucial. It first calls the constructor of its parent (GameObject) to \t\ninitialize the parts it's inheriting (the position). After the parent part is built, it then runs its own constructor code to initialize its specific \tattributes (name, battery_level).\n\n\tA Robot object can now use methods from both itself (reportStatus()) and its parent (reportPosition()).",
                    "code": "#include <iostream>\n#include <string>\n\nclass Vector2D {\npublic:\n    float x=0, y=0; Vector2D(float sX, float sY) : x(sX), y(sY) {}\n    void print() { std::cout << \"(\" << x << \", \" << y << \")\" << std::endl; }\n};\n\n// Parent Class: Defines properties common to all objects in our game world.\nclass GameObject {\npublic:\n    Vector2D position;\n    GameObject(float startX, float startY) : position(startX, startY) {}\n    void reportPosition() {\n        std::cout << \"Position: \";\n        position.print();\n    }\n};\n\n// Child Class: Inherits from GameObject and adds robot-specific details.\nclass Robot : public GameObject {\npublic:\n    std::string name;\n    int battery_level;\n\n    // The child constructor calls the parent constructor first.\n    Robot(std::string robotName, float startX, float startY) : GameObject(startX, startY) {\n        name = robotName;\n        battery_level = 100;\n    }\n\n    // This method uses both its own data and inherited methods.\n    void reportStatus() {\n        std::cout << \"Status for robot '\" << name << \"':\" << std::endl;\n        reportPosition(); // This method is inherited from GameObject.\n        std::cout << \"Battery: \" << battery_level << \"%.\" << std::endl;\n    }\n};\n\nint main() {\n    // When we create a Robot, it's also a GameObject.\n    Robot r2d2(\"R2-D2\", 50.0f, 75.0f);\n    r2d2.reportStatus();\n    return 0;\n}",
                    "output": "Status for robot 'R2-D2':\nPosition: (50, 75)\nBattery: 100%.```\n\n---"
                },
                "implementation": {
                    "explanation": "Inheritance\n\nGoal: To teach how a child class can reuse and extend a parent class to create specialized hardware controllers.\n\nConcept Explained: We define a generic parent class, Device, which has a common status. We then create two child classes: OLED_Display and DistanceSensor. The syntax : public Device means they inherit from Device. They automatically get the status attribute. Each child then adds its own unique hardware object and methods (displayText(), readDistance()). This demonstrates how to build a logical hierarchy, reusing common code (status) while creating specialized components.\n",
                    "code": "#include <Arduino.h>\n#include <Wire.h>\n#include <string>\n#include <VL53L0X.h>\n#include <Adafruit_GFX.h>\n#include <Adafruit_SSD1306.h>\n\n// =================================================================\n// CONCEPT: INHERITANCE\n// =================================================================\n\n// PARENT CLASS (Base Class)\nclass Device {\npublic:\n    std::string status;\n    Device() { status = \"Unitialized\"; }\n};\n\n// CHILD CLASS: An OLED_Display 'is-a' Device.\nclass OLED_Display : public Device {\npublic:\n    Adafruit_SSD1306 oled; // It contains the actual hardware object\n\n    OLED_Display() : oled(128, 64, &Wire, -1) {}\n\n    bool initialize() {\n        if (oled.begin(SSD1306_SWITCHCAPVCC, 0x3C)) {\n            status = \"OK\"; // It can access the inherited 'status' variable\n            return true;\n        }\n        status = \"FAILED\";\n        return false;\n    }\n\n    // A method unique to this child class\n    void displayText(const char* text) {\n        oled.clearDisplay(); oled.setTextSize(2); oled.setTextColor(WHITE);\n        oled.setCursor(0, 10); oled.println(text); oled.display();\n    }\n};\n\n// Another CHILD CLASS: A DistanceSensor 'is-a' Device.\nclass DistanceSensor : public Device {\npublic:\n    VL53L0X lox;\n\n    bool initialize() {\n        lox.setTimeout(500);\n        if (lox.init()) {\n            status = \"OK\";\n            lox.startContinuous();\n            return true;\n        }\n        status = \"FAILED\";\n        return false;\n    }\n\n    // A method unique to this child\n    int readDistance() {\n        return lox.readRangeContinuousMillimeters();\n    }\n};\n\n// Create objects of our specialized child classes.\nOLED_Display myDisplay;\nDistanceSensor mySensor;\n\nvoid setup() {\n    Serial.begin(115200);\n    Wire.begin();\n    delay(1000);\n    Serial.println(\"--- Program Start: Inheritance ---\\n\");\n    \n    myDisplay.initialize();\n    mySensor.initialize();\n    \n    Serial.print(\"Display Status: \");\n    Serial.println(myDisplay.status.c_str()); // Accessing inherited property\n    Serial.print(\"Sensor Status: \");\n    Serial.println(mySensor.status.c_str()); // Accessing inherited property\n}\n\nvoid loop() {\n  int distance = mySensor.readDistance();\n  myDisplay.displayText(std::to_string(distance).c_str());\n  delay(100);\n}"
                }
            },
            "Pointers": {
                "description": "At most basic level pointer is a varable that doesn't hold data but holds memory address",
                "concept": {
                    "explanation": "The Core Concept: What is a Pointer?\n\nAt its most basic level, a pointer is a variable that doesn't hold data, but holds a memory address.\n\nThe Best Analogy: A Contact in Your Phone\n\nImagine you have a friend named Alex.\n\nAlex himself is the actual data. He has a name, an age, etc.\nA regular variable is like having Alex in the room with you: string friend = \"Alex\";\n\nNow, imagine you save Alex's home address in your phone's contact list under the name \"AlexsHouse\".\n\nThe contact entry \"AlexsHouse\" is the pointer.\nThe address written inside it (\"123 Maple St.\") is the value of the pointer.\nThe contact entry itself is not Alex, but it tells you exactly where to find him.\n\nIf you want to send Alex a package, you don't put Alex himself in the mail. You use the address from your contact list (the pointer) to tell the mail service where to deliver the package. This is what pointers do for your program.\n\nWhy Bother Using Pointers?\n\nIn C++, pointers are fundamental for two main reasons:\n\nEfficiency: Imagine you have a huge, complex object. If you want a function to work with it, making a full copy is slow and wastes memory. Instead, you can just pass a pointer (the small \"address\" in your contacts). The function can then use that address to work with the one and only original object.\n\nDynamic Memory: Sometimes you don't know how many objects you'll need when you write your program. Pointers allow you to request new memory while the program is running (on the \"heap\") and store the address of that new memory in a pointer.\n",
                    "code": "#include <iostream>\n#include <string>\n\nint main() {\n    // --- 1. SETUP: Create a variable and a pointer to it ---\n\n    // This is our \"house\". It's a normal variable holding the value 100.\n    int score = 100;\n\n    // This is our \"contact entry\". \n    // 'int*' means \"this is a pointer that will hold the address of an integer\".\n    // We initialize it to nullptr, which means it's not pointing to anything yet.\n    int* scorePtr = nullptr;\n\n    // Now, let's get the address of 'score' and store it in our pointer.\n    // The '&' operator means \"give me the memory address of\".\n    scorePtr = &score;\n\n    // --- 2. DEMONSTRATION: Accessing data ---\n\n    std::cout << \"--- Accessing Data ---\" << std::endl;\n    // Print the value of the original variable directly.\n    std::cout << \"Direct value of 'score':\\t\\t\" << score << std::endl;\n\n    // Print the value the pointer is pointing to.\n    // The '*' operator here means \"dereference\". It says \"go to the address\n    // stored in scorePtr and get the value that lives there\".\n    std::cout << \"Value via pointer (*scorePtr):\\t\\t\" << *scorePtr << std::endl;\n\n    std::cout << \"\\n--- Viewing Addresses ---\" << std::endl;\n    // Print the memory address of the original variable.\n    std::cout << \"Memory address of 'score' (&score):\\t\" << &score << std::endl;\n\n    // Print the value of the pointer itself. Notice it's the same address!\n    std::cout << \"Value of the pointer (scorePtr):\\t\" << scorePtr << std::endl;\n\n    // --- 3. MODIFICATION: Changing data through the pointer ---\n\n    std::cout << \"\\n--- Modifying Data via Pointer ---\" << std::endl;\n    std::cout << \"Original score is: \" << score << std::endl;\n\n    // Use the dereference operator '*' to change the value AT the address.\n    // This is like sending a command to the house using its address.\n    std::cout << \"Executing: *scorePtr = 250;\" << std::endl;\n    *scorePtr = 250;\n\n    // Now, check the original variable. It has been changed!\n    std::cout << \"The value of 'score' is now:\\t\\t\" << score << std::endl;\n\n    return 0;\n}",
                    "output": "--- Accessing Data ---\nDirect value of 'score':              100\nValue via pointer (*scorePtr):        100\n\n--- Viewing Addresses ---\nMemory address of 'score' (&score):   0x7ffc1b3f6a2c\nValue of the pointer (scorePtr):      0x7ffc1b3f6a2c\n\n--- Modifying Data via Pointer ---\nOriginal score is: 100\nExecuting: *scorePtr = 250;\nThe value of 'score' is now:          250"
                },
                "implementation": {
                    "explanation": "Pointers\n\nGoal: To teach how a pointer (a variable holding a memory address) can be used to manage and control a hardware object.\n\nConcept Explained: This program creates a Robot class that does not contain a display object directly. Instead, it contains a pointer to a display object (Adafruit_SSD1306* displayPtr). This means the robot doesn't own the display, it's just given its address so it knows where to send commands. The & operator gets the display's address. The special arrow operator (->) is then used to call methods on the object that the pointer points to. This design pattern (Dependency Injection) makes the Robot class more flexible.",
                    "code": "#include <Arduino.h>\n#include <Wire.h>\n#include <string>\n#include <Adafruit_GFX.h>\n#include <Adafruit_SSD1306.h>\n\n// =================================================================\n// CONCEPT: POINTERS\n// A pointer is a variable that holds a memory address. We can use it\n// to dynamically choose which object's function to call.\n// =================================================================\n\n// --- Define an \"Interface\" using an Abstract Base Class ---\n// This blueprint says that any \"Blinker\" object MUST have a blink() method.\nclass Blinker {\npublic:\n    virtual void initialize() = 0; // Pure virtual function\n    virtual void blink() = 0;      // Pure virtual function\n};\n\n// --- First Implementation: Blinks the on-board LED ---\nclass LedBlinker : public Blinker {\npublic:\n    void initialize() override {\n        pinMode(LED_BUILTIN, OUTPUT);\n        Serial.println(\"On-board LED initialized.\");\n    }\n    \n    void blink() override {\n        Serial.println(\"Blinking on-board LED...\");\n        digitalWrite(LED_BUILTIN, HIGH);\n        delay(500);\n        digitalWrite(LED_BUILTIN, LOW);\n        delay(500);\n    }\n};\n\n// --- Second Implementation: Blinks a message on the OLED ---\nclass OledBlinker : public Blinker {\nprivate:\n    Adafruit_SSD1306 display;\n\npublic:\n    OledBlinker() : display(128, 64, &Wire, -1) {}\n\n    void initialize() override {\n        if (!display.begin(SSD1306_SWITCHCAPVCC, 0x3C)) {\n             Serial.println(\"OLED Failed!\");\n             for(;;);\n        }\n        Serial.println(\"OLED Display initialized.\");\n    }\n\n    void blink() override {\n        Serial.println(\"Blinking message on OLED...\");\n        display.clearDisplay();\n        display.setTextSize(2);\n        display.setTextColor(WHITE);\n        display.setCursor(20, 10);\n        display.println(\"BLINK!\");\n        display.display();\n        delay(500);\n        \n        display.clearDisplay();\n        display.display();\n        delay(500);\n    }\n};\n\n// --- Global Objects ---\nLedBlinker myLed;\nOledBlinker myOled;\n\n// This is our POINTER. It's a variable that can hold the address\n// of ANY object that is a \"Blinker\" (i.e., LedBlinker or OledBlinker).\nBlinker* currentBlinkerPtr = nullptr;\n\n\nvoid setup() {\n    Serial.begin(115200);\n    Wire.begin();\n    delay(1000);\n    Serial.println(\"--- Program Start: Pointers ---\");\n    \n    myLed.initialize();\n    myOled.initialize();\n\n    // --- Using the Pointer ---\n    // First, let's make the pointer hold the ADDRESS of the myLed object.\n    Serial.println(\"\\nSetting pointer to the LED Blinker...\");\n    currentBlinkerPtr = &myLed;\n}\n\nvoid loop() {\n    // This is the magic of pointers. We don't need to know if we are\n    // controlling the LED or the OLED. We just tell the pointer:\n    // \"Go to the address you're holding and call the blink() method on whatever object you find there.\"\n    currentBlinkerPtr->blink();\n    \n    // Every 5 blinks, we will SWITCH what the pointer is pointing to.\n    static int blinkCount = 0;\n    blinkCount++;\n    if (blinkCount % 5 == 0) {\n        // Check what the pointer is currently pointing to\n        if (currentBlinkerPtr == &myLed) {\n            // If it's pointing to the LED, switch it to point to the OLED\n            Serial.println(\"\\n>>> SWITCHING pointer to OLED Blinker <<<\");\n            currentBlinkerPtr = &myOled;\n        } else {\n            // If it's pointing to the OLED, switch it back to the LED\n            Serial.println(\"\\n>>> SWITCHING pointer back to LED Blinker <<<\");\n            currentBlinkerPtr = &myLed;\n        }\n    }\n}"
                }
            }
        }
    },
    "Algorithm": {
        "levels": {
            "Education": {},
            "Serial Printing": {
                "description": ""
            }
        }
    },
    "Control System": {
        "levels": {
            "Closed loop vs Open loop Control": {
                "description": "",
                "concept": {
                    "explanation": "\u2705 1. Topic Name\nClosed-Loop vs. Open-Loop Control\n\n\u2705 2. Concept\nWhat is it?\nThese are two fundamental control strategies:\n\nControl Type\tDescription\nOpen-Loop\tExecutes actions without any feedback from the environment. It assumes that the action will work as expected.\nClosed-Loop\tUses real-time feedback (like sensors) to monitor output and correct any error or deviation from the goal.\n\n\ud83d\udd27 Example in Daily Life:\nScenario\tOpen-Loop\tClosed-Loop\nMicrowave Oven\tRuns for fixed time, regardless of food temperature\tSmart oven adjusts time based on actual temperature\nFan\tTurns on and runs at full speed\tFan adjusts speed based on room temperature using sensor\nRobot Car\tMoves forward for 3s, without sensing obstacle\tAdjusts direction based on sensor distance\n\n\ud83e\udde0 Why It's Important in Your Robot Car\nYour robot car must react to obstacles to avoid collisions.\nIf it blindly moves forward (open-loop), it may crash.\nWith closed-loop control using VL53L0X distance sensor, it can stop or reverse when needed.",
                    "code": "void setup() {\n  moveForward(); // drive for 3 seconds\n  delay(3000);\n  stopMotors();\n}\n\n\nint distance = readSensor();\nif (distance < 150) {\n  moveBackward();\n} else if (distance > 250) {\n  moveForward();\n} else {\n  stopMotors();\n}",
                    "output": "Expected Output:\n    \u2022 Moves forward for 3 seconds, regardless of any obstacle.\nExpected Output:\n    \u2022 Moves based on real-time distance to obstacle."
                },
                "implementation": {
                    "explanation": "\u2705 Code Explanation\n\n    \u2022 VL53L0X reads distance in mm\n    \u2022 If too close (<150mm): go backward\n    \u2022 If too far (>250mm): go forward\n    \u2022 If just right: stop\n    \u2022 This is a true closed-loop system \u2014 the output (motor action) depends on real-time sensor input (distance).\n\n\n\u2705 How to Upload and Test\n\n    1. Open PlatformIO or Arduino IDE\n    2. Connect your ESP32\n    3. Install required libraries:\n        \u25e6 Adafruit VL53L0X\n    4. Connect:\n        \u25e6 VL53L0X: SDA/SCL to ESP32 I\u00b2C pins (e.g. GPIO 21/22)\n        \u25e6 L298N: IN1/IN2/ENA to motor control pins (as declared in code)\n    5. Upload code\n    6. Power robot \u2192 It will:\n        \u25e6 Move forward when far from obstacle\n        \u25e6 Move back when too close\n        \u25e6 Stop when in range\n\n\u2705 Summary\n\nFeature\nOpen-Loop\nClosed-Loop\nUses sensors?\n\u274c No\n\u2705 Yes (VL53L0X)\nReliable?\n\u274c Only in ideal\n\u2705 Works in real world\nRobot Safe?\n\u274c May crash\n\u2705 Avoids collisions\n",
                    "code": "#include <Wire.h>\n#include <VL53L0X.h>\n#include \"L298N.h\"  // Make sure you have your custom L298N.h library\n\n// Motor control pins: ENA, IN1, IN2\nL298N motor(14, 27, 26);\nVL53L0X sensor;\n\nvoid setup() {\n  Serial.begin(115200);\n  Wire.begin();  // Initialize I2C for VL53L0X\n\n  sensor.setTimeout(500);\n\n  if (!sensor.init()) {\n    Serial.println(\"VL53L0X not detected.\");\n    while (1);  // Stay here if sensor not found\n  }\n\n  sensor.startContinuous();  // Start taking continuous distance readings\n  motor.setSpeed(200);       // Set initial motor speed (0\u2013255)\n}\n\nvoid loop() {\n  int distance = sensor.readRangeContinuousMillimeters();\n\n  if (sensor.timeoutOccurred()) {\n    Serial.println(\"Sensor timeout\");\n    motor.stop();\n    return;\n  }\n\n  Serial.print(\"Distance: \");\n  Serial.print(distance);\n  Serial.println(\" mm\");\n\n  // Control logic: closed-loop based on distance\n  if (distance < 150) {\n    Serial.println(\"Too close: Reversing\");\n    motor.backward();\n  } else if (distance > 250) {\n    Serial.println(\"Too far: Moving forward\");\n    motor.forward();\n  } else {\n    Serial.println(\"In range: Stopping\");\n    motor.stop();\n  }\n\n  delay(100);\n}\n"
                }
            },
            "First-Order System Response": {
                "description": "",
                "concept": {
                    "explanation": " Topic 2: First-Order System Response\n\n\u2705 1. Topic Name\nFirst-Order System Response\n\n\n\u2705 2. Concept\n\n\ud83d\udcd8 What is a First-Order System?\n\nA first-order system is a dynamic system with a single energy storage element. Its behavior is described by a first-order differential equation. The output responds exponentially to a change in input.\n\n\ud83e\udde0 Time Response Equation (for step input)\n:\nmathematica\nCopy\nEdit\ny(t) = K * (1 - e^(-t/\u03c4))\n\nK is the final value\n\n\u03c4 (tau) is the time constant \u2014 how fast the system reaches the target\n\nAfter time = \u03c4, the system reaches about 63% of its final value\n\n\u2699\ufe0f Use in Control Systems\n\nGradual motor speed adjustment\n\nExponential sensor fusion (low-pass filters)\n\nCharging RC circuits (in electronics)\n\nIn robotics: smooth stopping, acceleration, deceleration\n\nInstead of moving instantly (which is not possible in real life), we simulate real-world gradual motion using first-order system logic.\n\n",
                    "code": "float target = 100;  // Desired position\nfloat current = 0;   // Current position\nfloat alpha = 0.1;   // Response factor\n\nvoid loop() {\n  current = current + alpha * (target - current);\n  Serial.println(current);\n  delay(100);\n}\n",
                    "output": "10.0\n19.0\n27.1\n34.39\n...\nApproaches 100 gradually (exponentially)\n"
                },
                "implementation": {
                    "explanation": "\u2705 4. Implementation on ESP32 Robot Car\n\n\ud83d\udd27 Goal: Robot gradually speeds up or slows down based on distance from an obstacle \u2014 simulating a first-order system response.\n\n\ud83e\uddf0 Hardware Used:\n\n    \u2022 ESP32 (e.g., ESP32 Devkit V1)\n    \u2022 Pololu VL53L0X distance sensor (I2C)\n    \u2022 L298N motor driver\n    \u2022 2 DC motors\n    \u2022 (Optional) OLED for distance display\n\n\u2705 Code Explanation:\n\nPart\nDescription\ndistance - setpoint\nCalculates how far the robot is from the desired 200 mm distance\ntargetSpeed = abs(error * 1.2)\nProportional control to decide how fast to go\ncurrentSpeed = currentSpeed + alpha * (targetSpeed - currentSpeed)\nFirst-order response \u2014 smooth update\nmotor.setSpeed(currentSpeed)\nUpdates actual motor PWM speed gradually\nmotor.forward() / backward()\nMoves toward the setpoint\n\n\u2705 What You Observe on the Robot:\n    \u2022 If the obstacle is far, the robot gradually speeds up and moves forward.\n    \u2022 As it gets close, the speed reduces exponentially.\n    \u2022 If it gets too close, it reverses smoothly.\n    \u2022 The transition is not abrupt \u2014 it follows first-order system behavior.\n\n\u2705 Summary Table:\nTerm\nMeaning\n\u03c4 (tau)\nSpeed of response (set via alpha)\nExponential\nSpeed rises/falls gradually\nUse Case\nSmooth driving, soft braking\n\n",
                    "code": "#include <Wire.h>\n#include <VL53L0X.h>\n#include \"L298N.h\"\n\n// Motor pins\nL298N motor(14, 27, 26);  // ENA, IN1, IN2\nVL53L0X sensor;\n\n// Control variables\nconst int setpoint = 200;  // Desired distance (mm)\nfloat currentSpeed = 0;    // Simulated gradual speed\nfloat alpha = 0.2;         // First-order response factor (0.0 - 1.0)\n\nvoid setup() {\n  Serial.begin(115200);\n  Wire.begin();\n  sensor.setTimeout(500);\n  \n  if (!sensor.init()) {\n    Serial.println(\"VL53L0X not found\");\n    while (1);\n  }\n\n  sensor.startContinuous();\n  motor.setSpeed(0);  // Start from 0\n}\n\nvoid loop() {\n  int distance = sensor.readRangeContinuousMillimeters();\n\n  if (sensor.timeoutOccurred()) {\n    Serial.println(\"Sensor timeout\");\n    motor.stop();\n    return;\n  }\n\n  int error = distance - setpoint;\n\n  // Convert error to target speed (P control)\n  float targetSpeed = constrain(abs(error * 1.2), 0, 255);\n\n  // First-order response: Gradually update current speed\n  currentSpeed = currentSpeed + alpha * (targetSpeed - currentSpeed);\n  motor.setSpeed((int)currentSpeed);\n\n  // Direction control based on error\n  if (error > 0) {\n    motor.forward();\n    Serial.print(\"\u2192 Forward | \");\n  } else if (error < 0) {\n    motor.backward();\n    Serial.print(\"\u2190 Backward | \");\n  } else {\n    motor.stop();\n    Serial.print(\"\u25a0 Stop | \");\n  }\n\n  // Serial monitoring\n  Serial.print(\"Distance: \");\n  Serial.print(distance);\n  Serial.print(\" mm | Speed: \");\n  Serial.println(currentSpeed);\n\n  delay(100);\n}\n"
                }
            },
            "Second-Order System Response": {
                "description": "",
                "concept": {
                    "explanation": "Topic 3: Second-Order System Response\n\n\u2705 1. Topic Name\nSecond-Order System Response\n\n\u2705 2. Concept\n\ud83d\udcd8 What is a Second-Order System?\nA second-order system has two energy-storing elements (like mass & spring). It responds to input with a dynamic that can include:\n    \u2022 Overshoot (go past target)\n    \u2022 Oscillations (wave-like motion)\n    \u2022 Settling time (how long to stabilize)\n    \u2022 Damping (how fast oscillations stop)\n\n\u2699\ufe0f System Equation:\nA standard second-order differential equation:\ny\u00a8\u200b(t)+2\u03b6\u03c9n\u200by\u02d9\u200b(t)+\u03c9n2\u200by(t)=K\u03c9n2\u200bu(t) \n    \u2022 \u03b6 = Damping ratio (zeta)\n    \u2022 \u03c9n\u200b = Natural frequency\n    \u2022 K = System gain\n    \u2022 Behavior depends on damping:\n        \u25e6 \u03b6<1: Underdamped (oscillates)\n        \u25e6 \u03b6=1: Critically damped (fastest settling)\n        \u25e6 \u03b6>1: Overdamped (slow, no oscillation)\n\n\ud83e\udde0 Use in Robotics\n    \u2022 Motor speed control (avoid jerky movement)\n    \u2022 Turning angle correction\n    \u2022 Obstacle distance adjustment with smooth response\nWhen your robot detects a wall, it shouldn\u2019t slam to a stop \u2014 instead, it should gently decelerate, possibly oscillating slightly before stopping.\n",
                    "code": "float pos = 0;        // Output (e.g., robot speed or distance)\nfloat vel = 0;        // Derivative of position\nfloat setpoint = 100; // Target value\nfloat damping = 0.7;  // \u03b6\nfloat k = 0.5;        // Spring constant (stiffness)\n\nvoid loop() {\n  float acc = k * (setpoint - pos) - damping * vel;  // F = -kx - bv\n  vel += acc;\n  pos += vel;\n\n  Serial.println(pos);\n  delay(100);\n}\n",
                    "output": "30\n60\n85\n102\n95\n99\n100.1\n100.0\n"
                },
                "implementation": {
                    "explanation": "\u2705 4. ESP32 Robot Car Implementation\n\ud83d\udd27 Goal: Robot uses second-order dynamics to approach a target distance with overshoot & damping effect (realistic motion behavior).\n\u2705 Code Explanation\nComponent\nRole\nerror = distance - setpoint\nMeasures how far robot is from target\nacc = k * error - damping * vel\nCalculates acceleration using 2nd-order system formula\nvel += acc\nVelocity update (integrate acceleration)\npos += vel\nPosition or control output update (integrate velocity)\nmotor.setSpeed(pos)\nApplies smoothed, realistic speed\nDirection logic\nBased on whether robot is too close/far\n\n\u2705 Behavior on Robot:\n    \u2022 Robot approaches the obstacle, speeding up\n    \u2022 When near the target distance:\n        \u25e6 It overshoots slightly\n        \u25e6 Then corrects in the opposite direction\n        \u25e6 Oscillates less with each pass\n    \u2022 Mimics real-world response like a mass-spring system\n\n\u2705 Summary Table\nTerm\nDescription\nDamping (\u03b6)\nControls how fast oscillation dies\nAcceleration\nOutput from error & velocity\nPosition\nSimulated movement profile\nUse Case\nSmooth navigation near targets\n\n",
                    "code": "#include <Wire.h>\n#include <VL53L0X.h>\n#include \"L298N.h\"\n\n// Motor control\nL298N motor(14, 27, 26);  // ENA, IN1, IN2\nVL53L0X sensor;\n\n// Second-order system states\nfloat pos = 0;             // Simulated speed or position\nfloat vel = 0;             // Rate of change of speed\nconst float damping = 0.7; // \u03b6 (0 < \u03b6 < 1 for underdamped)\nconst float k = 0.5;       // Gain\nconst int setpoint = 200;  // Desired distance in mm\n\nvoid setup() {\n  Serial.begin(115200);\n  Wire.begin();\n  sensor.setTimeout(500);\n\n  if (!sensor.init()) {\n    Serial.println(\"VL53L0X not found\");\n    while (1);\n  }\n\n  sensor.startContinuous();\n  motor.setSpeed(0);\n}\n\nvoid loop() {\n  int distance = sensor.readRangeContinuousMillimeters();\n\n  if (sensor.timeoutOccurred()) {\n    Serial.println(\"Sensor timeout\");\n    motor.stop();\n    return;\n  }\n\n  int error = distance - setpoint;\n\n  // Second-order update: acceleration = -kx - damping * vel\n  float acc = k * error - damping * vel;\n  vel += acc;\n  pos += vel;\n\n  // Convert 'pos' to motor speed (simulate physical behavior)\n  float speed = constrain(abs(pos), 0, 255);\n  motor.setSpeed((int)speed);\n\n  // Direction control\n  if (error > 0) {\n    motor.forward();\n    Serial.print(\"\u2192 Forward | \");\n  } else if (error < 0) {\n    motor.backward();\n    Serial.print(\"\u2190 Backward | \");\n  } else {\n    motor.stop();\n    Serial.print(\"\u25a0 Stop | \");\n  }\n\n  // Serial monitoring\n  Serial.print(\"Distance: \");\n  Serial.print(distance);\n  Serial.print(\" mm | Speed: \");\n  Serial.print(speed);\n  Serial.print(\" | Velocity: \");\n  Serial.println(vel);\n\n  delay(100);\n}\n"
                }
            },
            "PID Control (Propotional-Integrtion-Derivative)": {
                "description": "",
                "concept": {
                    "explanation": "Topic 4: PID Control (Proportional\u2013Integral\u2013Derivative)\n\n\u2705 1. Topic Name\nPID Control (Proportional\u2013Integral\u2013Derivative)\n\n\u2705 2. Concept\n\ud83d\udcd8 What is PID Control?\nA PID controller continuously calculates an error value as the difference between a desired setpoint and a measured process variable (like distance), and applies a correction based on:\n    \u2022 P \u2013 Proportional: Responds to current error\n    \u2022 I \u2013 Integral: Responds to past errors (accumulated over time)\n    \u2022 D \u2013 Derivative: Predicts future trend (rate of error change)\n\u2699\ufe0f PID Formula:\n\nu(t)=Kp\u200b\u22c5e(t)+Ki\u200b\u22c5\u222be(t)dt+Kd\u200b\u22c5dtde(t)\u200b \n\nTerm\nDescription\nKp\u200b\nProportional gain \u2014 immediate action\nKi\u200b\nIntegral gain \u2014 eliminate steady error\nKd\u200b\nDerivative gain \u2014 anticipate change\n\n\ud83e\udde0 Why Use PID in Robotics?\nPID is widely used for:\n    \u2022 Precise speed/distance/angle control\n    \u2022 Line following\n    \u2022 Obstacle tracking\n    \u2022 Velocity loop inside motor drivers\n    \u2022 Stability control (no overshoot, better responsiveness)\n",
                    "code": "float Kp = 1.0, Ki = 0.1, Kd = 0.5;\nfloat setpoint = 100;\nfloat prev_error = 0, integral = 0;\n\nvoid loop() {\n  float sensor_val = analogRead(A0);\n  float error = setpoint - sensor_val;\n  integral += error;\n  float derivative = error - prev_error;\n\n  float output = Kp * error + Ki * integral + Kd * derivative;\n  prev_error = error;\n\n  analogWrite(9, constrain(output, 0, 255));\n}\n",
                    "output": "\ud83d\udca1 Expected Output:\n    \u2022 Output gradually brings sensor_val to setpoint\n    \u2022 Integral accumulates small errors\n    \u2022 Derivative smooths response\n"
                },
                "implementation": {
                    "explanation": "\u2705 4. ESP32 Robot Car Implementation (Distance PID)\n\ud83d\udd27 Goal: Robot maintains a target distance (e.g. 200 mm) from obstacle using PID loop \u2014 stable and accurate.\n\u2705 Summary of Additions\nModule\nPurpose\nOLED\nReal-time visual feedback\nPID\nSmooth and accurate control\nVL53L0X\nDistance measurement\nMotor\nAdjust speed & directio\n\u2705 Code Explanation\nTerm\nPurpose\nKp * error\nReacts to current deviation\nKi * integral\nAccumulates past error (improves accuracy)\nKd * derivative\nStabilizes motion, dampens oscillation\ncontrol\nTotal PID output \u2192 used to adjust speed\nconstrain(abs(control), 0, 255)\nEnsures safe motor speed range\nmotor.forward() / backward()\nAdjusts direction based on whether the robot is too far or too close\n\n\u2705 Behavior of Robot:\n    \u2022 If too far, robot moves forward fast\n    \u2022 As it gets closer, speed reduces smoothly\n    \u2022 No jitter or aggressive bouncing near the obstacle\n    \u2022 If it overshoots, it reverses slightly, then stabilizes\n    \u2022 Achieves stable 200 mm distance\n\n\u2705 Summary\nFeature\nBenefit\nProportional\nFast reaction\nIntegral\nZero steady-state error\nDerivative\nNo overshoot, smoother stop\nOverall\nBalanced, stable robot behavior\n\nWould you like to:\n\u27a1\ufe0f Add OLED visualization of PID values (distance, error, output)?\n\u27a1\ufe0f Continue to Topic 5: Steady-State Error?\nLet me know, and we\u2019ll continue!\n",
                    "code": "#include <Wire.h>\n#include <VL53L0X.h>\n#include \"L298N.h\"\n#include <Adafruit_GFX.h>\n#include <Adafruit_SSD1306.h>\n\n// OLED setup\n#define SCREEN_WIDTH 128\n#define SCREEN_HEIGHT 64\nAdafruit_SSD1306 display(SCREEN_WIDTH, SCREEN_HEIGHT, &Wire, -1);\n\n// Motor + sensor\nL298N motor(14, 27, 26);\nVL53L0X sensor;\n\n// PID constants\nfloat Kp = 1.2;\nfloat Ki = 0.05;\nfloat Kd = 0.4;\n\n// Variables\nfloat setpoint = 200;        // mm\nfloat error, prev_error = 0;\nfloat integral = 0;\nfloat derivative = 0;\n\nvoid setup() {\n  Serial.begin(115200);\n  Wire.begin();\n\n  // OLED init\n  if (!display.begin(SSD1306_SWITCHCAPVCC, 0x3C)) {\n    Serial.println(\"OLED not found\");\n    while (1);\n  }\n  display.clearDisplay();\n  display.setTextColor(WHITE);\n  display.setTextSize(1);\n  display.setCursor(0, 0);\n  display.println(\"Robot Booting...\");\n  display.display();\n\n  // VL53L0X init\n  sensor.setTimeout(500);\n  if (!sensor.init()) {\n    Serial.println(\"VL53L0X not found\");\n    display.println(\"Sensor Error!\");\n    display.display();\n    while (1);\n  }\n  sensor.startContinuous();\n  motor.setSpeed(0);\n}\n\nvoid loop() {\n  int distance = sensor.readRangeContinuousMillimeters();\n  if (sensor.timeoutOccurred()) {\n    Serial.println(\"Sensor timeout\");\n    motor.stop();\n    return;\n  }\n\n  // PID control logic\n  error = setpoint - distance;\n  integral += error;\n  derivative = error - prev_error;\n  float control = Kp * error + Ki * integral + Kd * derivative;\n  prev_error = error;\n\n  float speed = constrain(abs(control), 0, 255);\n  motor.setSpeed((int)speed);\n\n  // Direction\n  if (error > 0) {\n    motor.forward();\n  } else if (error < 0) {\n    motor.backward();\n  } else {\n    motor.stop();\n  }\n\n  // --- OLED Display ---\n  display.clearDisplay();\n  display.setCursor(0, 0);\n  display.print(\"Distance: \");\n  display.print(distance);\n  display.println(\" mm\");\n\n  display.print(\"Error: \");\n  display.println(error);\n\n  display.print(\"PID Out: \");\n  display.println(speed);\n\n  display.print(\"Dir: \");\n  if (error > 0) display.println(\"Forward\");\n  else if (error < 0) display.println(\"Backward\");\n  else display.println(\"Stop\");\n\n  display.display();\n\n  // --- Serial Monitor ---\n  Serial.print(\"Distance: \");\n  Serial.print(distance);\n  Serial.print(\" mm | Error: \");\n  Serial.print(error);\n  Serial.print(\" | Speed: \");\n  Serial.println(speed);\n\n  delay(100);\n}\n"
                }
            },
            "Steady State Error": {
                "description": "",
                "concept": {
                    "explanation": "Topic 5: Steady-State Error in Unity-Feedback Control Systems\n\n\u2705 1. Topic Name\nSteady-State Error (SSE)\n\n\u2705 2. Concept\n\ud83d\udcd8 What is Steady-State Error?\nSteady-State Error (SSE) is the difference between the desired output (setpoint) and the actual output of a control system as time approaches infinity \u2014 in other words, how close the system gets to the target after it has settled.\nIt tells us how accurate the system is after all transient behaviors (oscillations, overshoots, etc.) have died out.\n\n\ud83d\udcca Where It's Used\n    \u2022 In robotics: maintaining a precise distance, speed, or position\n    \u2022 In motor control: ensuring that robot settles at exact target location\n    \u2022 In sensor feedback loops: e.g., keeping robot exactly 200 mm away from wall\n\n\u2699\ufe0f Why Does It Happen?\nIt depends on:\n    \u2022 Type of input (step, ramp, parabolic)\n    \u2022 Type of system (type 0, 1, 2...)\n    \u2022 Presence of integral action (eliminates SSE)\nSystem Type\nDescription\nSSE to Step\nType 0\nNo integrator in loop\nNon-zero\nType 1\nOne integrator (via Ki)\nZero\nType 2\nTwo integrators\nZero\nSo, to eliminate SSE, your robot needs integral control (Ki > 0).\n",
                    "code": "float setpoint = 100;\nfloat output = 0;\nfloat Kp = 0.5;\n\nvoid loop() {\n  float error = setpoint - output;\n  output += Kp * error;\n\n  Serial.println(output);\n  delay(100);\n}\n",
                    "output": "50\n75\n87.5\n93.75\n96.87\n... \u2192 Approaches setpoint but never reaches exactly \u2192 SSE \u2260 0\n"
                },
                "implementation": {
                    "explanation": "\u2705 How This Works\n\n    \u2022 Robot maintains 200 mm distance using PID\n    \u2022 Ki term integrates error over time \u2192 reduces SSE\n    \u2022 OLED shows real-time average SSE when robot is close to the setpoint\n    \u2022 If Ki = 0 \u2192 SSE will remain non-zero\n    \u2022 If Ki > 0 \u2192 SSE gradually reduces to zero\n\n\ud83d\udcc8 Sample Output on OLED\n\nmakefile\nCopyEdit\nDist: 201 mm\nError: -1\nSpeed: 20\nSSE: 2.40\nOver time, SSE will drop below 1 if your tuning is correct.\n\n\u2705 Summary\n\nTerm\nDescription\nSSE\nError remaining after settling\nEliminated using\nIntegral control (Ki > 0)\nMeasurement\nAvg error when robot is near setpoint\nOLED Display\nShows error, speed, SSE\n",
                    "code": "#include <Wire.h>\n#include <VL53L0X.h>\n#include \"L298N.h\"\n#include <Adafruit_GFX.h>\n#include <Adafruit_SSD1306.h>\n\n// OLED\n#define SCREEN_WIDTH 128\n#define SCREEN_HEIGHT 64\nAdafruit_SSD1306 display(SCREEN_WIDTH, SCREEN_HEIGHT, &Wire, -1);\n\n// Components\nL298N motor(14, 27, 26);\nVL53L0X sensor;\n\n// PID\nfloat Kp = 1.2;\nfloat Ki = 0.08;   // Non-zero Ki to eliminate SSE\nfloat Kd = 0.4;\n\n// State\nfloat setpoint = 200;      // mm\nfloat error, prev_error = 0;\nfloat integral = 0;\nfloat derivative = 0;\n\n// SSE tracking\nfloat steadyErrorSum = 0;\nint steadyCount = 0;\nfloat avgSSE = 0;\n\nvoid setup() {\n  Serial.begin(115200);\n  Wire.begin();\n\n  if (!display.begin(SSD1306_SWITCHCAPVCC, 0x3C)) {\n    Serial.println(\"OLED not found\");\n    while (1);\n  }\n\n  display.clearDisplay();\n  display.setTextColor(WHITE);\n  display.setTextSize(1);\n  display.setCursor(0, 0);\n  display.println(\"Booting...\");\n  display.display();\n\n  sensor.setTimeout(500);\n  if (!sensor.init()) {\n    display.println(\"Sensor error\");\n    display.display();\n    while (1);\n  }\n\n  sensor.startContinuous();\n  motor.setSpeed(0);\n}\n\nvoid loop() {\n  int distance = sensor.readRangeContinuousMillimeters();\n  if (sensor.timeoutOccurred()) {\n    Serial.println(\"Sensor timeout\");\n    motor.stop();\n    return;\n  }\n\n  error = setpoint - distance;\n  integral += error;\n  derivative = error - prev_error;\n  float control = Kp * error + Ki * integral + Kd * derivative;\n  prev_error = error;\n\n  float speed = constrain(abs(control), 0, 255);\n  motor.setSpeed((int)speed);\n\n  if (error > 0) motor.forward();\n  else if (error < 0) motor.backward();\n  else motor.stop();\n\n  // Measure SSE after settling\n  if (abs(error) < 10) {\n    steadyErrorSum += abs(error);\n    steadyCount++;\n    avgSSE = steadyErrorSum / steadyCount;\n  }\n\n  // --- OLED Display ---\n  display.clearDisplay();\n  display.setCursor(0, 0);\n  display.print(\"Dist: \");\n  display.print(distance);\n  display.println(\" mm\");\n\n  display.print(\"Error: \");\n  display.println(error);\n\n  display.print(\"Speed: \");\n  display.println(speed);\n\n  display.print(\"SSE: \");\n  display.println(avgSSE, 2);  // Show SSE as average\n\n  display.display();\n\n  // --- Serial ---\n  Serial.print(\"Distance: \");\n  Serial.print(distance);\n  Serial.print(\" mm | Error: \");\n  Serial.print(error);\n  Serial.print(\" | Speed: \");\n  Serial.print(speed);\n  Serial.print(\" | SSE: \");\n  Serial.println(avgSSE, 2);\n\n  delay(100);\n}\n"
                }
            },
            "State-Space Representation": {
                "description": "",
                "concept": {
                    "explanation": "New concept explanation...",
                    "code": "// New concept code...",
                    "output": "New concept output..."
                },
                "implementation": {
                    "explanation": "\u2705 4. ESP32 Robot Implementation (State-Based Control)\nWe'll now simulate position and velocity as state variables, and use them to control motor behavior more intelligently.\n\u2705 How This Works\nElement\nRole\npos\nUpdated from sensor (state x\u2081)\nvel\nUpdated by acceleration\ncontrol\nComputed using state feedback\nacc\nControl signal (acts like u)\nMotor logic\nActs based on velocity\n\n\ud83d\udcc8 Output on OLED\nmakefile\nCopyEdit\nDist: 215 mm\nVel: -1.20\nAcc: 0.43\nCtrl: 0.43\nRobot slows down as it nears target distance.\n\n\u2705 Summary\nTerm\nDescription\nState\nVariables describing system's internal status\nState Eq.\nPredicts next state based on current inputs\nOutput Eq.\nComputes output from state\nBenefit\nWorks for multi-input, multi-output (MIMO), dynamic behaviors\n",
                    "code": "#include <Wire.h>\n#include <VL53L0X.h>\n#include \"L298N.h\"\n#include <Adafruit_GFX.h>\n#include <Adafruit_SSD1306.h>\n\n// OLED\n#define SCREEN_WIDTH 128\n#define SCREEN_HEIGHT 64\nAdafruit_SSD1306 display(SCREEN_WIDTH, SCREEN_HEIGHT, &Wire, -1);\n\n// Components\nL298N motor(14, 27, 26);\nVL53L0X sensor;\n\n// Time step\nconst float dt = 0.1;\n\n// State variables\nfloat pos = 300;     // Initial guess (mm)\nfloat vel = 0;\n\n// Gains\nfloat k = 0.05;       // Stiffness gain\nfloat b = 0.25;       // Damping\n\n// Setpoint\nconst float target = 200;  // Desired distance\n\nvoid setup() {\n  Serial.begin(115200);\n  Wire.begin();\n\n  if (!display.begin(SSD1306_SWITCHCAPVCC, 0x3C)) {\n    Serial.println(\"OLED failed\");\n    while (1);\n  }\n\n  display.clearDisplay();\n  display.setTextColor(WHITE);\n  display.setTextSize(1);\n  display.setCursor(0, 0);\n  display.println(\"State-Space Init...\");\n  display.display();\n\n  sensor.setTimeout(500);\n  if (!sensor.init()) {\n    Serial.println(\"Sensor error\");\n    while (1);\n  }\n\n  sensor.startContinuous();\n  motor.setSpeed(0);\n}\n\nvoid loop() {\n  int measured = sensor.readRangeContinuousMillimeters();\n  if (sensor.timeoutOccurred()) {\n    Serial.println(\"Sensor timeout\");\n    motor.stop();\n    return;\n  }\n\n  // Update state using measured position\n  pos = measured;\n\n  // Control input u = -Kx = -k*pos - b*vel\n  float control = -k * (pos - target) - b * vel;\n\n  // Apply control to velocity (acceleration = control)\n  float acc = control;\n  vel += acc * dt;\n\n  // Set motor\n  float speed = constrain(abs(vel * 10), 0, 255);\n  motor.setSpeed((int)speed);\n  if (vel > 0) motor.forward();\n  else if (vel < 0) motor.backward();\n  else motor.stop();\n\n  // --- OLED Display ---\n  display.clearDisplay();\n  display.setCursor(0, 0);\n  display.print(\"Dist: \"); display.print(measured); display.println(\" mm\");\n  display.print(\"Vel: \"); display.println(vel, 2);\n  display.print(\"Acc: \"); display.println(acc, 2);\n  display.print(\"Ctrl: \"); display.println(control, 2);\n  display.display();\n\n  // --- Serial Output ---\n  Serial.print(\"Measured: \"); Serial.print(measured);\n  Serial.print(\" | Vel: \"); Serial.print(vel);\n  Serial.print(\" | Acc: \"); Serial.print(acc);\n  Serial.print(\" | Ctrl: \"); Serial.println(control);\n\n  delay(100);\n}\n"
                }
            },
            "Controllability and Observability": {
                "description": "",
                "concept": {
                    "explanation": "\ud83d\udd37 Topic 7: Controllability and Observability\n\n\u2705 1. Topic Name\nControllability and Observability\n\n\u2705 2. Concept (General Control System Theory)\n\ud83d\udcd8 What is Controllability?\nA system is controllable if we can drive it from any initial state to any desired final state in a finite amount of time using a valid input.\n    \u2022 Mathematically, a system is controllable if the controllability matrix has full rank.\n    \u2022 For state-space systems:\nx\u02d9(t)=Ax(t)+Bu(t) \nThe Controllability Matrix is:\nC=[BABA2B\u22efAn\u22121B] \nIf rank(C)=n, then the system is controllable.\n\n\ud83d\udcd8 What is Observability?\nA system is observable if, by observing its output over time, we can determine the entire internal state.\n    \u2022 Mathematically, observability checks whether the system\u2019s states can be reconstructed from outputs.\nGiven:\ny(t)=Cx(t)+Du(t) \nThe Observability Matrix is:\nO=\u200bCCACA2\u22eeCAn\u22121\u200b\u200b \nIf rank(O)=n, the system is observable.\n\n\ud83c\udfaf Why It\u2019s Important in Control Systems\nFeature\nApplication\nControllability\nEnsures we can move robot to any state (turn, stop, speed)\nObservability\nAllows us to estimate hidden states (like velocity)\nBoth together\nNeeded for modern control design (e.g., observers, LQR)\n\n\ud83e\udde0 Real-Life Example (Non-ESP)\nLet\u2019s say a drone is flying, and:\n    \u2022 We can apply thrust = Controllability\n    \u2022 We can estimate its position/speed from GPS/IMU = Observability\n",
                    "code": "#include <iostream>\n#include <Eigen/Dense>\nusing namespace std;\nusing namespace Eigen;\n\nint main() {\n    Matrix2f A;\n    A << 0, 1,\n         -2, -3;\n         \n    Vector2f B;\n    B << 0, 1;\n\n    Matrix2f C;\n    C << 1, 0;\n\n    // Controllability matrix\n    Matrix2f ctrl;\n    ctrl << B, A * B;\n\n    // Observability matrix\n    Matrix2f obs;\n    obs << C,\n           C * A;\n\n    cout << \"Controllability matrix:\\n\" << ctrl << endl;\n    cout << \"Observability matrix:\\n\" << obs << endl;\n\n    cout << \"Rank of controllability: \" << ctrl.fullPivLu().rank() << endl;\n    cout << \"Rank of observability: \" << obs.fullPivLu().rank() << endl;\n\n    return 0;\n}\n",
                    "output": "Controllability matrix:\n0  1\n1 -3\n\nObservability matrix:\n1  0\n0  1\n\nRank of controllability: 2\nRank of observability: 2\n"
                },
                "implementation": {
                    "explanation": "\u2705 5. ESP32 Robot Car Implementation\n\n\ud83d\udd27 Use Case: Estimate Robot Velocity (observability) + Control Position (controllability)\nWe\u2019ll:\n    \u2022 Use VL53L0X to measure distance\n    \u2022 Estimate velocity (a hidden state)\n    \u2022 Use PID to control motion (demonstrating controllability\n\n\u2705 6. Detailed Explanation of Code\nSection\nPurpose\nSensor reading\nReads current distance (measured state)\nVelocity est.\nApproximates velocity using \u2206x/\u2206t \u2014 hidden state (observability)\nPID Control\nUses distance error to control motor (demonstrates controllability)\nOLED display\nShows distance, velocity, and PID output in real time\nOutput logic\nMotor moves robot forward/backward to achieve target distance\n\n\ud83d\udca1 Key Concept Mapping:\nConcept\nIn Code\nControllability\nUsing PID to drive robot to any distance\nObservability\nEstimating velocity from position changes (\u2206x/\u2206t)\nState-space model\nDistance (x1), Velocity (x2), Input (motor), Output (sensor)\n",
                    "code": "#include <Wire.h>\n#include <VL53L0X.h>\n#include \"L298N.h\"\n#include <Adafruit_GFX.h>\n#include <Adafruit_SSD1306.h>\n\n// OLED settings\n#define SCREEN_WIDTH 128\n#define SCREEN_HEIGHT 64\nAdafruit_SSD1306 display(SCREEN_WIDTH, SCREEN_HEIGHT, &Wire, -1);\n\n// Motor and sensor\nL298N motor(14, 27, 26);  // ENA, IN1, IN2\nVL53L0X sensor;\n\n// State variables\nfloat position = 0;\nfloat velocity = 0;\nfloat previous_position = 0;\nconst float dt = 0.1;\n\n// PID variables\nfloat setpoint = 200;  // mm\nfloat error = 0, previous_error = 0;\nfloat integral = 0;\nfloat Kp = 1.4, Ki = 0.05, Kd = 0.5;\n\nvoid setup() {\n  Serial.begin(115200);\n  Wire.begin();\n\n  // OLED init\n  if (!display.begin(SSD1306_SWITCHCAPVCC, 0x3C)) {\n    Serial.println(\"OLED failed\");\n    while (1);\n  }\n\n  display.clearDisplay();\n  display.setTextColor(WHITE);\n  display.setTextSize(1);\n  display.setCursor(0, 0);\n  display.println(\"Controllability & Observability\");\n  display.display();\n\n  // Sensor init\n  sensor.setTimeout(500);\n  if (!sensor.init()) {\n    Serial.println(\"VL53L0X error\");\n    while (1);\n  }\n\n  sensor.startContinuous();\n  motor.setSpeed(0);\n}\n\nvoid loop() {\n  // 1. Read distance\n  position = sensor.readRangeContinuousMillimeters();\n  if (sensor.timeoutOccurred()) {\n    Serial.println(\"Sensor timeout\");\n    motor.stop();\n    return;\n  }\n\n  // 2. Estimate velocity (observability)\n  velocity = (position - previous_position) / dt;\n  previous_position = position;\n\n  // 3. PID control (controllability)\n  error = setpoint - position;\n  integral += error * dt;\n  float derivative = (error - previous_error) / dt;\n  previous_error = error;\n\n  float output = Kp * error + Ki * integral + Kd * derivative;\n  float speed = constrain(abs(output), 0, 255);\n  motor.setSpeed((int)speed);\n  if (output > 0) motor.forward();\n  else if (output < 0) motor.backward();\n  else motor.stop();\n\n  // 4. Display\n  display.clearDisplay();\n  display.setCursor(0, 0);\n  display.print(\"Dist: \"); display.println(position);\n  display.print(\"Vel: \"); display.println(velocity, 2);\n  display.print(\"PID: \"); display.println(output, 2);\n  display.display();\n\n  // 5. Debug\n  Serial.print(\"Dist: \"); Serial.print(position);\n  Serial.print(\" | Vel: \"); Serial.print(velocity);\n  Serial.print(\" | PID: \"); Serial.println(output);\n\n  delay(dt * 1000);\n}\n"
                }
            },
            "Ziegler-Nichols PID Tuning": {
                "description": "",
                "concept": {
                    "explanation": "\ud83d\udd37 Topic 8: Ziegler\u2013Nichols PID Tuning\n\n\u2705 1. Topic Name\nZiegler\u2013Nichols PID Tuning\n\n\u2705 2. Concept (General Control System Theory)\n\ud83d\udcd8 What is PID Tuning?\nA PID Controller has 3 terms:\n    \u2022 P (Proportional): reacts to current error\n    \u2022 I (Integral): reacts to accumulated error over time\n    \u2022 D (Derivative): reacts to the rate of error change\nTo make PID effective, we must tune these constants:\n\u2192 Kp (gain), Ki (integral gain), Kd (derivative gain)\n\n\ud83d\udcd8 What is Ziegler\u2013Nichols Tuning Method?\nZiegler\u2013Nichols is a practical, empirical method to tune PID controllers by applying a rule-based approach.\n\n\ud83c\udfaf Two Main Ziegler\u2013Nichols Methods:\n\n1. Step Response Method (for open-loop tuning):\n    \u2022 Apply a step input\n    \u2022 Record the system\u2019s S-curve\n    \u2022 From the curve, extract:\n        \u25e6 L = delay time\n        \u25e6 T = time constant\n\n\n2. Ultimate Gain Method (closed-loop):\n    \u2022 Remove I and D \u2192 set Ki = Kd = 0\n    \u2022 Increase Kp until the system oscillates continuously\n    \u2022 Note:\n        \u25e6 Ku = ultimate gain (the Kp at which it oscillates)\n        \u25e6 Tu = oscillation period\n\n\n\ud83d\udcc8 Where It\u2019s Used\n    \u2022 In industry: fast setup for temperature, speed, distance control\n    \u2022 In robotics: when tuning robot response (e.g., stopping accurately)\n\n",
                    "code": "// Only Proportional gain\nfloat Kp = 2.5;\nfloat Ki = 0; // Initially zero\nfloat Kd = 0; // Initially zero\n\nfloat error = setpoint - measured;\nfloat output = Kp * error;\n\n// Observe if system oscillates continuously \u2192 find Ku, Tu\n",
                    "output": "\u2705 4. Expected Output\nWhen Kp is increased:\n    \u2022 System begins to respond faster\n    \u2022 If Kp is too high, robot oscillates (goes back/forth)\n    \u2022 Once sustained oscillation occurs \u2192 that\u2019s Ku, and you note Tu\nThen apply ZN formulas to calculate real Kp, Ki, Kd\n"
                },
                "implementation": {
                    "explanation": "\u2705 6. Explanation of Code (How It Implements ZN Tuning)\nSection\tExplanation\nKp only\tStarts with only Proportional control to observe oscillation behavior\nManual tuning\tYou increase Kp manually in code and watch for sustained oscillation\nKu, Tu\tNote Ku (value where robot oscillates), and time Tu between cycles\nApply ZN rules\tUse PID formulas to set Kp, Ki, Kd\nPID enabled\tOnce tuned, full PID is used to make robot stop accurately at target\nOLED/Serial\tShows distance, error, and PID output in real time\n\n\ud83d\udcdd Example ZN Calculation (You do this after code test)\nLet\u2019s say:\n\nYou found Ku = 3.8\n\nOscillation period Tu = 1.2 seconds\n",
                    "code": "#include <Wire.h>\n#include <VL53L0X.h>\n#include \"L298N.h\"\n#include <Adafruit_GFX.h>\n#include <Adafruit_SSD1306.h>\n\n// OLED\n#define SCREEN_WIDTH 128\n#define SCREEN_HEIGHT 64\nAdafruit_SSD1306 display(SCREEN_WIDTH, SCREEN_HEIGHT, &Wire, -1);\n\n// Components\nVL53L0X sensor;\nL298N motor(14, 27, 26);\n\n// PID Setup\nfloat setpoint = 200; // Target distance in mm\n\nfloat Kp = 3.2;  // Start low, increase until oscillation \u2192 note as Ku\nfloat Ki = 0;\nfloat Kd = 0;\n\nfloat error = 0, previous_error = 0, integral = 0;\nfloat dt = 0.1;\n\nvoid setup() {\n  Serial.begin(115200);\n  Wire.begin();\n\n  if (!display.begin(SSD1306_SWITCHCAPVCC, 0x3C)) {\n    Serial.println(\"OLED failed\");\n    while (1);\n  }\n\n  display.clearDisplay();\n  display.setTextColor(WHITE);\n  display.setCursor(0, 0);\n  display.println(\"ZN PID Tuning...\");\n  display.display();\n\n  sensor.setTimeout(500);\n  if (!sensor.init()) {\n    Serial.println(\"VL53L0X error\");\n    while (1);\n  }\n\n  sensor.startContinuous();\n  motor.setSpeed(0);\n}\n\nvoid loop() {\n  int distance = sensor.readRangeContinuousMillimeters();\n  if (sensor.timeoutOccurred()) {\n    Serial.println(\"Sensor timeout\");\n    motor.stop();\n    return;\n  }\n\n  // PID Calculations\n  error = setpoint - distance;\n  integral += error * dt;\n  float derivative = (error - previous_error) / dt;\n  previous_error = error;\n\n  float output = Kp * error + Ki * integral + Kd * derivative;\n  float speed = constrain(abs(output), 0, 255);\n  motor.setSpeed((int)speed);\n  if (output > 0) motor.forward();\n  else if (output < 0) motor.backward();\n  else motor.stop();\n\n  // Display\n  display.clearDisplay();\n  display.setCursor(0, 0);\n  display.print(\"Dist: \"); display.println(distance);\n  display.print(\"Err: \"); display.println(error);\n  display.print(\"Out: \"); display.println(output);\n  display.print(\"Kp: \"); display.println(Kp);\n  display.display();\n\n  // Serial monitor logging\n  Serial.print(\"Distance: \"); Serial.print(distance);\n  Serial.print(\" | Output: \"); Serial.print(output);\n  Serial.print(\" | Kp: \"); Serial.println(Kp);\n\n  delay(dt * 1000);\n}\n"
                }
            },
            "Transient and Steady-State Respoonse": {
                "description": "",
                "concept": {
                    "explanation": "\ud83d\udd37 Topic 9: Transient and Steady-State Response\n\n\u2705 1. Topic Name\nTransient and Steady-State Response\n\n\u2705 2. Concept (General Control System Theory)\n\ud83d\udcd8 What is Transient Response?\nThe transient response is the part of a system\u2019s output that changes over time before reaching its final value (steady-state).\nIt includes:\n    \u2022 Rise Time \u2013 Time to go from 10% to 90% of final value\n    \u2022 Peak Time \u2013 Time to reach maximum overshoot\n    \u2022 Overshoot \u2013 How much the system exceeds final value\n    \u2022 Settling Time \u2013 Time to stay within \u00b15% of the final value\n    \u2022 Damping \u2013 Whether it oscillates or not\nTransient response tells you how fast and how stably your system reacts to input.\n\n\ud83d\udcd8 What is Steady-State Response?\nThe steady-state response is the final behavior of the system after all transients have died out.\n    \u2022 It tells us accuracy and stability over long time\n    \u2022 Steady-State Error is the difference between desired and final output\n\n\ud83c\udfaf Real-World Examples\nScenario\nTransient Behavior\nSteady-State Behavior\nRobot moves to 20 cm\nThe first few seconds of movement\nFinally stops at 20 cm\nCar cruise control\nSpeed changes for few seconds\nSpeed settles at desired value\nLight dimmer\nLED brightness changing\nReaches final brightness level\n",
                    "code": "float Kp = 1.5, Ki = 0.2, Kd = 0.3;\nfloat setpoint = 100;  // Desired position\nfloat measured = 0;\nfloat error = setpoint - measured;\nfloat output = Kp * error + Ki * integral + Kd * derivative;\n",
                    "output": "Time (s) | Output\n-------- | -------\n0        | 0\n0.5      | 60\n1.0      | 110  (overshoot)\n1.5      | 98   (oscillation)\n2.5      | 100  (steady-state)\n"
                },
                "implementation": {
                    "explanation": "\u2705 5. ESP32 Robot Car Implementation\nWe\u2019ll command the robot to move to a specific distance (e.g. 200 mm), then monitor:\n    \u2022 How fast it gets there (transient)\n    \u2022 Whether it stops at the correct spot (steady-state)\n    \u2022 How much it overshoots or oscillates\nOLED and Serial monitor will visualize both parts.\n\u2705 6. Detailed Explanation of Code\nFeature\nPurpose\nVL53L0X sensor\nMeasures real-time distance from obstacle\nPID controller\nAdjusts motor output to reach and stop at target\nError + Derivative\nHelp reduce overshoot and oscillations (transient behavior)\nIntegral term\nEliminates steady-state error\nOLED/Serial monitor\nTrack live distance and how fast/stably it reaches target\nTime tracking\nLets us calculate rise time, peak time, settling time from logs\n\n\ud83d\udcdd What You'll See in Output\n    \u2022 Robot moves quickly toward 200 mm\n    \u2022 It may overshoot (250 mm)\n    \u2022 Then comes back, settles around 200 mm\n    \u2022 You can use Serial logs to calculate rise time, overshoot, and settling time\n    \u2022 Eventually it stops = steady-state\n\n\u2705 Summary\nTerm\nMeaning\nIn Robot Code\nTransient response\nInitial movement behavior\nRise, overshoot, settling\nSteady-state\nFinal, stable output\nRobot stops at 200 mm\nPID tuning\nControls both transient + steady-state\nCombined PID output\n",
                    "code": "#include <Wire.h>\n#include <VL53L0X.h>\n#include \"L298N.h\"\n#include <Adafruit_GFX.h>\n#include <Adafruit_SSD1306.h>\n\n// OLED\n#define SCREEN_WIDTH 128\n#define SCREEN_HEIGHT 64\nAdafruit_SSD1306 display(SCREEN_WIDTH, SCREEN_HEIGHT, &Wire, -1);\n\n// Motor + Sensor\nL298N motor(14, 27, 26);  // ENA, IN1, IN2\nVL53L0X sensor;\n\n// PID Constants\nfloat setpoint = 200;  // mm\nfloat Kp = 1.5, Ki = 0.1, Kd = 0.3;\n\n// PID variables\nfloat error = 0, previous_error = 0;\nfloat integral = 0;\nfloat dt = 0.1;\n\n// Time tracking\nunsigned long start_time;\n\nvoid setup() {\n  Serial.begin(115200);\n  Wire.begin();\n\n  // OLED init\n  if (!display.begin(SSD1306_SWITCHCAPVCC, 0x3C)) {\n    Serial.println(\"OLED failed\");\n    while (1);\n  }\n\n  display.clearDisplay();\n  display.setTextColor(WHITE);\n  display.setTextSize(1);\n  display.setCursor(0, 0);\n  display.println(\"PID Response Monitor\");\n  display.display();\n\n  // VLX init\n  sensor.setTimeout(500);\n  if (!sensor.init()) {\n    Serial.println(\"VL53L0X error\");\n    while (1);\n  }\n  sensor.startContinuous();\n\n  motor.setSpeed(0);\n  start_time = millis();\n}\n\nvoid loop() {\n  int distance = sensor.readRangeContinuousMillimeters();\n  if (sensor.timeoutOccurred()) {\n    Serial.println(\"Sensor timeout\");\n    motor.stop();\n    return;\n  }\n\n  // PID Calculations\n  error = setpoint - distance;\n  integral += error * dt;\n  float derivative = (error - previous_error) / dt;\n  previous_error = error;\n\n  float output = Kp * error + Ki * integral + Kd * derivative;\n\n  // Motor logic\n  int speed = constrain(abs(output), 0, 255);\n  motor.setSpeed(speed);\n  if (output > 0) motor.forward();\n  else if (output < 0) motor.backward();\n  else motor.stop();\n\n  // Display values\n  display.clearDisplay();\n  display.setCursor(0, 0);\n  display.print(\"Target: \"); display.println(setpoint);\n  display.print(\"Current: \"); display.println(distance);\n  display.print(\"Error: \"); display.println(error);\n  display.print(\"Time: \"); display.println((millis() - start_time) / 1000.0);\n  display.display();\n\n  // Log for transient/SS analysis\n  Serial.print(\"Time: \"); Serial.print((millis() - start_time) / 1000.0);\n  Serial.print(\" | Dist: \"); Serial.print(distance);\n  Serial.print(\" | Err: \"); Serial.print(error);\n  Serial.print(\" | PID: \"); Serial.println(output);\n\n  delay(dt * 1000);\n}\n"
                }
            },
            "State Machine Control for Behavior Logic": {
                "description": "",
                "concept": {
                    "explanation": "\ud83d\udd37 Topic 10: State Machine Control for Behavior Logic\n\n\u2705 1. Topic Name\nState Machine Control for Behavior Logic\n\n\u2705 2. Concept (General Control System Theory)\n\ud83d\udcd8 What is a State Machine?\nA Finite State Machine (FSM) is a control model where a system can be in one of several defined states, and transitions between those states based on input conditions.\nEach state defines:\n    \u2022 What the system is doing\n    \u2022 What output or action is taken\n    \u2022 What conditions cause it to move to another state\n\n\ud83e\udde0 Why State Machines?\nControl systems often need decision-making logic, especially in robotics:\n    \u2022 A robot might need to switch between \u201cSearching\u201d, \u201cMoving Forward\u201d, \u201cAvoiding Obstacle\u201d, or \u201cStopping\u201d\n    \u2022 These are states\n    \u2022 Transitions happen when certain conditions (like sensor readings) occur\n\n\ud83d\udd04 Components of a State Machine\n    \u2022 States: Modes of operation (e.g., IDLE, FORWARD, AVOID)\n    \u2022 Events/Conditions: Triggers for changing states (e.g., distance < 100mm)\n    \u2022 Transitions: How you move from one state to another\n    \u2022 Actions: What is done in each state (e.g., turn motor ON)\n\n\ud83d\udcd0 Visual Example\nscss\nCopyEdit\n[ IDLE ]\n   \u2193  (button pressed)\n[ MOVING ]\n   \u2193 (distance < 150mm)\n[ AVOIDING ]\n   \u2193 (clear)\n[ MOVING ]\n",
                    "code": "enum State { IDLE, MOVING, AVOIDING };\nState current = IDLE;\n\nvoid loop() {\n  switch (current) {\n    case IDLE:\n      if (buttonPressed()) current = MOVING;\n      break;\n    case MOVING:\n      if (distanceSensor() < 150) current = AVOIDING;\n      break;\n    case AVOIDING:\n      if (distanceSensor() > 200) current = MOVING;\n      break;\n  }\n}\n",
                    "output": "\u2705 4. Expected Output\n    \u2022 System starts in IDLE\n    \u2022 When condition is met, moves to MOVING\n    \u2022 If obstacle is detected, moves to AVOIDING\n    \u2022 Once obstacle clears, returns to MOVING\nYou see transitions based on sensor input \u2014 this is what makes FSMs powerful.\n"
                },
                "implementation": {
                    "explanation": "\nState\nAction\nTransition Condition\nIDLE\nStop all motors\nAfter 5 seconds\nFORWARD\nMove forward\nIf obstacle < 150 mm \u2192 go to AVOID\nAVOID\nReverse for 1 sec + stop\nAfter 1 sec \u2192 go back to FORWARD\n\n\nComponent\nFunction\nenum RobotState\nHolds all possible states: IDLE, FORWARD, AVOID\nswitch (state)\nDecides what to do in each state\nVL53L0X reading\nTriggers transition if obstacle detected\nstateStartTime\nUsed for time-based transitions (e.g., IDLE \u2192 FORWARD after 5 sec)\nOLED display\nShows live state\nmotor.forward()\nAction in FORWARD state\nmotor.backward()\nAction in AVOID state (simple backup)\n\nStart: IDLE\n[After 5 sec] \u2192 FORWARD\nObstacle < 150 mm \u2192 AVOID\n[After 1 sec] \u2192 FORWARD again\n\n\nConcept\nIn Robot Code\nState machine\nFSM with IDLE \u2192 FORWARD \u2192 AVOID \u2192 FORWARD\nTransitions\nBased on time or distance\nBehavior logic\nClearly separated in code structure\nExpandability\nEasy to add new states like \u201cTurning\u201d\n",
                    "code": "#include <Wire.h>\n#include <VL53L0X.h>\n#include \"L298N.h\"\n#include <Adafruit_GFX.h>\n#include <Adafruit_SSD1306.h>\n\n// OLED\n#define SCREEN_WIDTH 128\n#define SCREEN_HEIGHT 64\nAdafruit_SSD1306 display(SCREEN_WIDTH, SCREEN_HEIGHT, &Wire, -1);\n\n// Motor + Sensor\nL298N motor(14, 27, 26);\nVL53L0X sensor;\n\n// FSM States\nenum RobotState { IDLE, FORWARD, AVOID };\nRobotState state = IDLE;\n\nunsigned long stateStartTime = 0;\n\nvoid showOLED(String s) {\n  display.clearDisplay();\n  display.setCursor(0, 0);\n  display.setTextSize(1);\n  display.setTextColor(WHITE);\n  display.println(\"State Machine\");\n  display.print(\"State: \"); display.println(s);\n  display.display();\n}\n\nvoid setup() {\n  Serial.begin(115200);\n  Wire.begin();\n\n  // OLED\n  if (!display.begin(SSD1306_SWITCHCAPVCC, 0x3C)) {\n    Serial.println(\"OLED failed\");\n    while (1);\n  }\n\n  // VLX Sensor\n  sensor.setTimeout(500);\n  if (!sensor.init()) {\n    Serial.println(\"VL53L0X error\");\n    while (1);\n  }\n  sensor.startContinuous();\n\n  motor.setSpeed(180);\n  stateStartTime = millis();\n  showOLED(\"IDLE\");\n}\n\nvoid loop() {\n  int distance = sensor.readRangeContinuousMillimeters();\n  unsigned long now = millis();\n\n  switch (state) {\n\n    case IDLE:\n      motor.stop();\n      if (now - stateStartTime > 5000) {  // After 5s\n        state = FORWARD;\n        stateStartTime = now;\n        Serial.println(\"\u2192 FORWARD\");\n        showOLED(\"FORWARD\");\n      }\n      break;\n\n    case FORWARD:\n      if (distance < 150) {\n        motor.backward();\n        state = AVOID;\n        stateStartTime = now;\n        Serial.println(\"Obstacle Detected! \u2192 AVOID\");\n        showOLED(\"AVOID\");\n      } else {\n        motor.forward();\n      }\n      break;\n\n    case AVOID:\n      if (now - stateStartTime > 1000) {  // reverse for 1s\n        state = FORWARD;\n        stateStartTime = now;\n        Serial.println(\"\u2192 FORWARD\");\n        showOLED(\"FORWARD\");\n      }\n      break;\n  }\n\n  // Serial log\n  Serial.print(\"State: \"); Serial.print(state);\n  Serial.print(\" | Dist: \"); Serial.println(distance);\n\n  delay(100);\n}\n"
                }
            },
            "Lead-Lag Compensation (brief intro for tuning logic)": {
                "description": "",
                "concept": {
                    "explanation": "\ud83d\udd37 Topic 11: Lead\u2013Lag Compensation\n\n\u2705 1. Topic Name\nLead\u2013Lag Compensation\n\n\u2705 2. Concept (General Control System Theory)\n\ud83d\udcd8 What is Compensation?\nIn control systems, compensation means improving system performance by adding extra components (controllers or filters). This helps you:\n    \u2022 Improve transient response (speed and stability)\n    \u2022 Improve steady-state accuracy\n    \u2022 Reduce overshoot or delay\nTwo major types:\n\n\ud83d\udfe9 Lead Compensation\n    \u2022 Adds a zero before a pole in the transfer function\n    \u2022 Speeds up the system response\n    \u2022 Increases stability margin\n    \u2022 Reduces rise time\nThink of it as making the system \u201cmore responsive\u201d\n\n\ud83d\udfe8 Lag Compensation\n    \u2022 Adds a pole before a zero\n    \u2022 Improves steady-state error\n    \u2022 Doesn\u2019t speed up system much\nThink of it as \u201cfine-tuning accuracy\u201d\n\n\ud83d\udfe7 Lag\u2013Lead Compensation\n    \u2022 Combines both:\n        \u25e6 Lead improves speed and damping\n        \u25e6 Lag improves accuracy\n\n\ud83d\udcd0 Analogy\nSituation\nUse\nRobot responds slowly\nAdd lead\nRobot stops at wrong distance\nAdd lag\nYou want both speed & accuracy\nUse lag\u2013lead\n\n\u2699\ufe0f Transfer Function Concept\nLet\u2019s say you have a system with transfer function:\nG(s)=s(s+2)1\u200b \nAdd a lead compensator:\n\u00a0Glead\u200b(s)=s+ps+z\u200bwhere\u00a0z<p",
                    "code": "s = tf('s');\nG = 1 / (s * (s + 2));\nLead = (s + 5) / (s + 20);\nT = Lead * G;\nstep(T)\n",
                    "output": "Expected Output:\n\nFaster rise\n\nReduced overshoot\n\n"
                },
                "implementation": {
                    "explanation": "\u2705 4. ESP32 Robot Car Implementation\n\nWhile we don\u2019t design analog filters in embedded code, we simulate Lead or Lag behavior through modifying PID behavior.\nWe\u2019ll now build:\n    \u2022 A Lead-Like behavior by increasing derivative gain (Kd)\n    \u2022 A Lag-Like behavior by increasing integral gain (Ki)\nThis lets us observe effects on speed and accuracy.\nWe\u2019ll show both on the OLED as well.\n\u2705 5. Explanation of Code (Simulating Lead\u2013Lag)\n\nSection\nPurpose\nHigh Kd\nSimulates lead compensation \u2014 reacts fast to change\nHigh Ki\nSimulates lag compensation \u2014 corrects final error\nOLED Display\nShows real-time tuning values and system behavior\nDistance sensor\nUsed to control robot\u2019s stop point\n\n\n\ud83e\uddea How to Test Lead\u2013Lag\n    \u2022 Set Kd = 0 and increase Ki \u2192 observe improved steady-state\n    \u2022 Set Ki = 0 and increase Kd \u2192 observe faster but possibly more oscillatory behavior\n    \u2022 Combine both \u2192 get faster and accurate robot behavior\n\n\ud83e\udde0 Summary\n\nConcept\nRobot Equivalent\nLead compensation\nReacts quickly, reduces rise time (via Kd)\nLag compensation\nImproves accuracy, reduces final error (via Ki)\nCombined control\nSmooth and accurate navigation\n",
                    "code": "#include <Wire.h>\n#include <VL53L0X.h>\n#include \"L298N.h\"\n#include <Adafruit_GFX.h>\n#include <Adafruit_SSD1306.h>\n\n// OLED\n#define SCREEN_WIDTH 128\n#define SCREEN_HEIGHT 64\nAdafruit_SSD1306 display(SCREEN_WIDTH, SCREEN_HEIGHT, &Wire, -1);\n\n// Motor + Sensor\nVL53L0X sensor;\nL298N motor(14, 27, 26);\n\n// Target\nfloat setpoint = 200;  // mm\n\n// PID (Lead = more Kd, Lag = more Ki)\nfloat Kp = 1.5;\nfloat Ki = 0.5;  // Lag effect\nfloat Kd = 1.2;  // Lead effect\n\nfloat error = 0, previous_error = 0;\nfloat integral = 0;\nfloat dt = 0.1;\n\nvoid setup() {\n  Serial.begin(115200);\n  Wire.begin();\n\n  // OLED\n  if (!display.begin(SSD1306_SWITCHCAPVCC, 0x3C)) {\n    Serial.println(\"OLED failed\");\n    while (1);\n  }\n\n  // Sensor\n  sensor.setTimeout(500);\n  if (!sensor.init()) {\n    Serial.println(\"VL53L0X init failed\");\n    while (1);\n  }\n\n  sensor.startContinuous();\n  motor.setSpeed(0);\n}\n\nvoid loop() {\n  int distance = sensor.readRangeContinuousMillimeters();\n  if (sensor.timeoutOccurred()) {\n    Serial.println(\"Sensor timeout\");\n    motor.stop();\n    return;\n  }\n\n  // PID\n  error = setpoint - distance;\n  integral += error * dt;\n  float derivative = (error - previous_error) / dt;\n  previous_error = error;\n\n  float output = Kp * error + Ki * integral + Kd * derivative;\n\n  int speed = constrain(abs(output), 0, 255);\n  motor.setSpeed(speed);\n  if (output > 0) motor.forward();\n  else if (output < 0) motor.backward();\n  else motor.stop();\n\n  // OLED\n  display.clearDisplay();\n  display.setCursor(0, 0);\n  display.setTextSize(1);\n  display.setTextColor(WHITE);\n  display.println(\"Lead-Lag PID\");\n  display.print(\"Dist: \"); display.println(distance);\n  display.print(\"Err: \"); display.println(error);\n  display.print(\"Kp: \"); display.println(Kp);\n  display.print(\"Ki: \"); display.println(Ki);\n  display.print(\"Kd: \"); display.println(Kd);\n  display.display();\n\n  // Serial Output\n  Serial.print(\"Distance: \"); Serial.print(distance);\n  Serial.print(\" | Output: \"); Serial.println(output);\n\n  delay(dt * 1000);\n}\n"
                }
            },
            "OLED-Based Feedback Visualization": {
                "description": "",
                "concept": {
                    "explanation": "\ud83d\udd37 Topic 12: OLED-Based Feedback Visualization\n\n\u2705 1. Topic Name\nOLED-Based Feedback Visualization\n\n\u2705 2. Concept (General Explanation)\n\ud83d\udcd8 What is OLED-Based Feedback?\n\nIn control systems, feedback is vital for understanding what the system is doing in real-time.\nUsing an OLED display allows us to:\n\n    \u2022 Visually track sensor values, error, state, or motor speeds\n    \u2022 Debug and verify the control system logic on the robot itself\n    \u2022 Observe system performance without needing a serial monitor\n\n\ud83e\udde0 Why Use OLED in Robotics?\n\nBenefit\nExample\nView sensor input\nShow real-time distance\nTrack control performance\nShow error values, PID outputs\nDisplay state of FSM\nShow current behavior (IDLE, MOVE)\nVisual tuning\nView effect of Kp, Ki, Kd on screen\n\n\ud83d\uddbc\ufe0f Visualization Options\n\n    1. Text-based updates\n        \u25e6 Show values like: Distance, Error, State\n        \u25e6 \n    2. Bar graph or graphical lines\n        \u25e6 Show values moving in real time (more advanced)\n\n",
                    "code": "#include <Wire.h>\n#include <VL53L0X.h>\n#include <Adafruit_GFX.h>\n#include <Adafruit_SSD1306.h>\n\nVL53L0X sensor;\n#define SCREEN_WIDTH 128\n#define SCREEN_HEIGHT 64\nAdafruit_SSD1306 display(SCREEN_WIDTH, SCREEN_HEIGHT, &Wire, -1);\n\nvoid setup() {\n  Serial.begin(115200);\n  Wire.begin();\n\n  if (!display.begin(SSD1306_SWITCHCAPVCC, 0x3C)) {\n    Serial.println(\"OLED init failed\");\n    while (1);\n  }\n\n  sensor.setTimeout(500);\n  if (!sensor.init()) {\n    Serial.println(\"Sensor not found\");\n    while (1);\n  }\n  sensor.startContinuous();\n}\n\nvoid loop() {\n  int distance = sensor.readRangeContinuousMillimeters();\n\n  display.clearDisplay();\n  display.setCursor(0, 0);\n  display.setTextSize(1);\n  display.setTextColor(WHITE);\n  display.println(\"Distance Sensor\");\n  display.print(\"Distance: \");\n  display.print(distance);\n  display.println(\" mm\");\n  display.display();\n\n  delay(200);\n}\n",
                    "output": "Distance Sensor\nDistance: 187 mm\n"
                },
                "implementation": {
                    "explanation": "\u2705 5. ESP32 Robot Car Implementation\n\n(OLED + PID + State + Sensor + Motor)\nNow we\u2019ll show:\n    \u2022 Distance from sensor\n    \u2022 PID error and output\n    \u2022 Motor direction\n    \u2022 System state (like FORWARD, AVOID)\n\u2705 6. Explanation of Code Behavior\n\nSection\nRole\nOLED Display\nShows distance, PID error, control constants, and state\nFSM State\nControls robot logic (IDLE \u2192 FORWARD \u2192 AVOID)\nPID\nAdjusts motor speed to reach and stay at target distance\nFeedback View\nHelps in tuning PID or debugging sensor/motor issues\n\n\ud83e\udde0 Summary\n\nFeature\nIn Code\nFeedback visualization\nReal-time OLED display\nSystem insights\nPID error, distance, and state\nDebugging aid\nKnow exactly what robot is doing\n",
                    "code": "#include <Wire.h>\n#include <VL53L0X.h>\n#include \"L298N.h\"\n#include <Adafruit_GFX.h>\n#include <Adafruit_SSD1306.h>\n\n// OLED setup\n#define SCREEN_WIDTH 128\n#define SCREEN_HEIGHT 64\nAdafruit_SSD1306 display(SCREEN_WIDTH, SCREEN_HEIGHT, &Wire, -1);\n\n// Motor and sensor\nL298N motor(14, 27, 26);\nVL53L0X sensor;\n\n// PID constants\nfloat setpoint = 200;  // Target distance in mm\nfloat Kp = 1.5, Ki = 0.2, Kd = 0.3;\nfloat error = 0, prev_error = 0, integral = 0;\nfloat dt = 0.1;\n\n// FSM states\nenum State { IDLE, FORWARD, AVOID };\nState state = IDLE;\nunsigned long stateStart = 0;\n\nvoid setup() {\n  Serial.begin(115200);\n  Wire.begin();\n\n  // OLED init\n  if (!display.begin(SSD1306_SWITCHCAPVCC, 0x3C)) {\n    Serial.println(\"OLED failed\");\n    while (1);\n  }\n\n  // VL53L0X init\n  sensor.setTimeout(500);\n  if (!sensor.init()) {\n    Serial.println(\"VL53L0X failed\");\n    while (1);\n  }\n  sensor.startContinuous();\n\n  motor.setSpeed(0);\n  stateStart = millis();\n}\n\nvoid loop() {\n  int distance = sensor.readRangeContinuousMillimeters();\n  if (sensor.timeoutOccurred()) {\n    Serial.println(\"Sensor timeout\");\n    motor.stop();\n    return;\n  }\n\n  // FSM logic\n  switch (state) {\n    case IDLE:\n      motor.stop();\n      if (millis() - stateStart > 3000) {\n        state = FORWARD;\n        stateStart = millis();\n      }\n      break;\n\n    case FORWARD:\n      if (distance < 150) {\n        motor.backward();\n        state = AVOID;\n        stateStart = millis();\n      } else {\n        // PID control\n        error = setpoint - distance;\n        integral += error * dt;\n        float derivative = (error - prev_error) / dt;\n        prev_error = error;\n        float output = Kp * error + Ki * integral + Kd * derivative;\n\n        int speed = constrain(abs(output), 0, 255);\n        motor.setSpeed(speed);\n        if (output > 0) motor.forward();\n        else motor.backward();\n      }\n      break;\n\n    case AVOID:\n      if (millis() - stateStart > 1000) {\n        state = FORWARD;\n        stateStart = millis();\n      }\n      break;\n  }\n\n  // OLED feedback\n  display.clearDisplay();\n  display.setCursor(0, 0);\n  display.setTextSize(1);\n  display.setTextColor(WHITE);\n  display.println(\"Robot Car Feedback\");\n  display.print(\"State: \");\n  display.println(state == IDLE ? \"IDLE\" : (state == FORWARD ? \"FORWARD\" : \"AVOID\"));\n  display.print(\"Distance: \"); display.println(distance);\n  display.print(\"Error: \"); display.println(error);\n  display.print(\"Kp: \"); display.println(Kp);\n  display.print(\"Ki: \"); display.println(Ki);\n  display.print(\"Kd: \"); display.println(Kd);\n  display.display();\n\n  delay(dt * 1000);\n}\n"
                }
            },
            "Sensor Noise Handling & Filtering": {
                "description": "",
                "concept": {
                    "explanation": "\ud83d\udd37 Topic 13: Sensor Noise Handling & Filtering\n\n\u2705 1. Topic Name\nSensor Noise Handling & Filtering\n\n\u2705 2. Concept (Control System Explanation)\n\ud83d\udcd8 What is Sensor Noise?\n\nSensor noise is the unwanted fluctuation in measurements that aren\u2019t caused by real changes in the environment.\nFor example, your VL53L0X sensor may read:\nmakefile\nCopyEdit\nDistance: 204 mm \u2192 198 mm \u2192 206 mm \u2192 200 mm\n...even when the object is not moving.\nThis instability can confuse the robot, especially in control loops.\n\n\ud83e\udde0 Why Filtering Is Important\n\nWithout filtering:\n    \u2022 Your robot might oscillate or respond to false readings\n    \u2022 The PID controller may overreact\n    \u2022 You get jittery movement\n\n\ud83d\udee0\ufe0f Types of Filtering (Basic)\n\nMethod\nDescription\nMoving Average\nAverage of the last N readings \u2013 smooths out noise\nExponential Filter\nApplies weight to current vs past readings (a form of low-pass filtering)\nMedian Filter\nTakes the middle value \u2013 good for rejecting spikes\n\n",
                    "code": "#define N 5\nint readings[N];\nint index = 0;\n\nint getFilteredDistance(int raw) {\n  readings[index] = raw;\n  index = (index + 1) % N;\n\n  int sum = 0;\n  for (int i = 0; i < N; i++) {\n    sum += readings[i];\n  }\n  return sum / N;\n}\n",
                    "output": "Raw: 204, 198, 206, 200, 202\nFiltered: 202\n"
                },
                "implementation": {
                    "explanation": "\u2705 4. ESP32 Robot Car Implementation\n\n\u27a1 We\u2019ll add moving average filtering before using sensor data in PID control and FSM decisions.\n\n\u2705 5. Explanation of Working\n\nSection\nWhat It Does\nreadings[N]\nStores the last N distance values\ngetFilteredDistance()\nAverages them for smooth result\nrawDistance\nDirect sensor reading from VL53L0X\ndistance\nFiltered result passed to FSM and PID\nOLED\nShows both raw and filtered values to observe filter effect\nResult\nRobot reacts smoothly to true distance without flickering or jittering\n\n\u2705 Summary\n\nConcept\nImplemented As\nSensor noise\nRaw VL53L0X readings\nFiltering method\nMoving average of 5 readings\nBenefit\nStable readings, smoother motor control\nOLED\nHelps visualize filter effect\n",
                    "code": "#include <Wire.h>\n#include <VL53L0X.h>\n#include \"L298N.h\"\n#include <Adafruit_GFX.h>\n#include <Adafruit_SSD1306.h>\n\n// OLED setup\n#define SCREEN_WIDTH 128\n#define SCREEN_HEIGHT 64\nAdafruit_SSD1306 display(SCREEN_WIDTH, SCREEN_HEIGHT, &Wire, -1);\n\n// Motor + Sensor\nL298N motor(14, 27, 26);\nVL53L0X sensor;\n\n// PID setup\nfloat setpoint = 200;\nfloat Kp = 1.5, Ki = 0.2, Kd = 0.3;\nfloat error = 0, prev_error = 0, integral = 0;\nfloat dt = 0.1;\n\n// FSM states\nenum State { IDLE, FORWARD, AVOID };\nState state = IDLE;\nunsigned long stateStart = 0;\n\n// Moving Average Filter\n#define N 5\nint readings[N] = {0};\nint readIndex = 0;\n\nint getFilteredDistance(int newVal) {\n  readings[readIndex] = newVal;\n  readIndex = (readIndex + 1) % N;\n  int sum = 0;\n  for (int i = 0; i < N; i++) sum += readings[i];\n  return sum / N;\n}\n\nvoid setup() {\n  Serial.begin(115200);\n  Wire.begin();\n\n  if (!display.begin(SSD1306_SWITCHCAPVCC, 0x3C)) {\n    Serial.println(\"OLED failed\");\n    while (1);\n  }\n\n  sensor.setTimeout(500);\n  if (!sensor.init()) {\n    Serial.println(\"VL53L0X failed\");\n    while (1);\n  }\n  sensor.startContinuous();\n  motor.setSpeed(0);\n  stateStart = millis();\n}\n\nvoid loop() {\n  int rawDistance = sensor.readRangeContinuousMillimeters();\n  if (sensor.timeoutOccurred()) {\n    Serial.println(\"Sensor timeout\");\n    motor.stop();\n    return;\n  }\n\n  int distance = getFilteredDistance(rawDistance);\n\n  // FSM Logic\n  switch (state) {\n    case IDLE:\n      motor.stop();\n      if (millis() - stateStart > 3000) {\n        state = FORWARD;\n        stateStart = millis();\n      }\n      break;\n\n    case FORWARD:\n      if (distance < 150) {\n        motor.backward();\n        state = AVOID;\n        stateStart = millis();\n      } else {\n        error = setpoint - distance;\n        integral += error * dt;\n        float derivative = (error - prev_error) / dt;\n        prev_error = error;\n\n        float output = Kp * error + Ki * integral + Kd * derivative;\n\n        int speed = constrain(abs(output), 0, 255);\n        motor.setSpeed(speed);\n        if (output > 0) motor.forward();\n        else if (output < 0) motor.backward();\n        else motor.stop();\n      }\n      break;\n\n    case AVOID:\n      if (millis() - stateStart > 1000) {\n        state = FORWARD;\n        stateStart = millis();\n      }\n      break;\n  }\n\n  // OLED feedback\n  display.clearDisplay();\n  display.setCursor(0, 0);\n  display.setTextSize(1);\n  display.setTextColor(WHITE);\n  display.println(\"Sensor Filtering\");\n  display.print(\"Raw: \"); display.println(rawDistance);\n  display.print(\"Filtered: \"); display.println(distance);\n  display.print(\"Error: \"); display.println(error);\n  display.print(\"State: \");\n  display.println(state == IDLE ? \"IDLE\" : (state == FORWARD ? \"FORWARD\" : \"AVOID\"));\n  display.display();\n\n  delay(dt * 1000);\n}\n"
                }
            },
            "System Stability: Oscillation and Damping": {
                "description": "",
                "concept": {
                    "explanation": "\ud83d\udd37 Topic 14: System Stability \u2013 Oscillation and Damping\n\n\u2705 1. Topic Name\nSystem Stability: Oscillation and Damping\n\n\u2705 2. Concept (Control System Explanation)\n\ud83d\udcd8 What is System Stability?\nA control system is stable if its output remains bounded over time for any bounded input.\nIn robot terms:\n    \u2022 If a robot reacts to a nearby object and keeps vibrating or oscillating, it is unstable\n    \u2022 If it moves smoothly and settles to the desired state or position, it's stable\n\n\ud83e\udde0 Oscillation and Damping\n    \u2022 Oscillation: System continuously overshoots and undershoots (zig-zag behavior)\n    \u2022 Damping: Reduces oscillation over time\nTypes of System Response:\nResponse Type\nDescription\nUnderdamped\nOscillates but eventually settles\nCritically Damped\nFastest response without oscillation\nOverdamped\nNo oscillation, but very slow to reach target\nUnstable\nOscillations grow or never settle\nDamping Ratio (\u03b6) determines the type of response.\n\n\ud83d\udcca Use in Robot Car\nIf the car keeps moving back and forth near the target distance, it\u2019s underdamped.\nYou need to adjust PID gains to reduce the oscillation:\n    \u2022 Reduce Kp (to avoid aggressive reaction)\n    \u2022 Increase Kd (adds damping effect)\n    \u2022 Tune Ki carefully (integral wind-up can destabilize system)\n",
                    "code": "float setpoint = 200;\nfloat Kp = 2.0;  // High = more overshoot\nfloat Ki = 0.5;\nfloat Kd = 1.5;  // Damping term\n\n// result: fast reaction + moderate damping\n",
                    "output": "Expected Behavior:\n    \u2022 If Kp too high: robot shakes\n    \u2022 If Kd high enough: system damps and stabilizes"
                },
                "implementation": {
                    "explanation": "\u2705 4. ESP32 Robot Car Implementation\n\nWe\u2019ll now make a version that:\n    \u2022 Reacts to sensor input\n    \u2022 Uses PID control\n    \u2022 Uses OLED to show whether the system is damping properly\n    \u2022 Helps observe oscillation vs damping\n\u2705 5. Explanation of Code Behavior\n\nPart\nExplanation\nKp = 2.0\nStrong proportional control, can cause overshoot\nKd = 1.5\nHelps reduce oscillation (damping effect)\nFiltered Distance\nReduces noisy input, improves stability\nOLED Display\nShows real-time error, speed, and whether system stabilizes\n\n\ud83e\udde0 Test Case\n\nScenario\nWhat to Observe\nObject stays constant\nOutput and speed decrease to zero (stable)\nObject approaches\nSystem reacts fast, settles (damped)\nWrong PID gains\nRobot shakes or overcorrects (unstable)\n\n\ud83d\udcca Summary\n\nConcept\nIn Practice\nOscillation\nOutput jumps back and forth\nDamping\nSystem smoothly reaches setpoint\nStability tuning via PID\nAdjust Kp, Ki, Kd to control behavior\nVisualized via OLED\nEasy to monitor system performance\n",
                    "code": "#include <Wire.h>\n#include <VL53L0X.h>\n#include \"L298N.h\"\n#include <Adafruit_GFX.h>\n#include <Adafruit_SSD1306.h>\n\n// OLED\n#define SCREEN_WIDTH 128\n#define SCREEN_HEIGHT 64\nAdafruit_SSD1306 display(SCREEN_WIDTH, SCREEN_HEIGHT, &Wire, -1);\n\n// Sensor + Motor\nVL53L0X sensor;\nL298N motor(14, 27, 26);\n\n// PID\nfloat setpoint = 200;  // Desired distance in mm\nfloat Kp = 2.0, Ki = 0.4, Kd = 1.5;  // Try tweaking these\nfloat error, prev_error = 0, integral = 0;\nfloat dt = 0.1;\n\n// Moving average filter\n#define N 5\nint readings[N] = {0};\nint r_index = 0;\n\nint getFilteredDistance(int val) {\n  readings[r_index] = val;\n  r_index = (r_index + 1) % N;\n  int sum = 0;\n  for (int i = 0; i < N; i++) sum += readings[i];\n  return sum / N;\n}\n\nvoid setup() {\n  Serial.begin(115200);\n  Wire.begin();\n\n  if (!display.begin(SSD1306_SWITCHCAPVCC, 0x3C)) {\n    Serial.println(\"OLED failed\");\n    while (1);\n  }\n\n  sensor.setTimeout(500);\n  if (!sensor.init()) {\n    Serial.println(\"VL53L0X failed\");\n    while (1);\n  }\n  sensor.startContinuous();\n  motor.setSpeed(0);\n}\n\nvoid loop() {\n  int raw = sensor.readRangeContinuousMillimeters();\n  if (sensor.timeoutOccurred()) {\n    Serial.println(\"Sensor timeout\");\n    motor.stop();\n    return;\n  }\n\n  int distance = getFilteredDistance(raw);\n\n  // PID calculations\n  error = setpoint - distance;\n  integral += error * dt;\n  float derivative = (error - prev_error) / dt;\n  prev_error = error;\n\n  float output = Kp * error + Ki * integral + Kd * derivative;\n\n  int speed = constrain(abs(output), 0, 255);\n  motor.setSpeed(speed);\n  if (output > 0) motor.forward();\n  else if (output < 0) motor.backward();\n  else motor.stop();\n\n  // OLED Display\n  display.clearDisplay();\n  display.setCursor(0, 0);\n  display.setTextSize(1);\n  display.setTextColor(WHITE);\n  display.println(\"Oscillation/Damping\");\n  display.print(\"Target: \"); display.println(setpoint);\n  display.print(\"Distance: \"); display.println(distance);\n  display.print(\"Error: \"); display.println(error);\n  display.print(\"Output: \"); display.println(output);\n  display.print(\"Speed: \"); display.println(speed);\n  display.display();\n\n  delay(dt * 1000);\n}\n"
                }
            },
            "Autonomous Obstacle Avoidance using Control Loops": {
                "description": "",
                "concept": {
                    "explanation": "\ud83d\udd37 Topic 15: Autonomous Obstacle Avoidance Using Control Loops\n\n\u2705 1. Topic Name\n\nAutonomous Obstacle Avoidance Using Control Loops\n\n\u2705 2. Concept (Control System + Robotics)\n\n\ud83d\udcd8 What Is Autonomous Obstacle Avoidance?\n\nIt\u2019s a technique that allows the robot to:\n    \u2022 Sense nearby objects (e.g., using VL53L0X sensors)\n    \u2022 Decide how to react (avoid, stop, or reroute)\n    \u2022 Act by changing its path using motors\nThis logic runs in a control loop, constantly:\n    1. Reading distance\n    2. Making a decision\n    3. Executing motor commands\n\n\ud83e\udde0 Why Use a Control Loop?\n\nInstead of blindly reacting, we:\n    \u2022 Use sensor thresholds to define safe zones\n    \u2022 Use if-else logic or FSM (Finite State Machine) to define behavior\n    \u2022 Use PID or timed movement for smooth escape and re-alignment\n\n\ud83d\udea7 Obstacle Zones (Logic-Based)\n\nZone\nAction\nDistance < 120 mm\nObstacle very close \u2192 Stop + Reverse or Turn\nDistance < 200 mm\nSlow down or prepare to turn\nDistance > 200 mm\nMove forward freely\nWe build a state machine around these conditions.\n",
                    "code": "int distance = readSensor();\n\nif (distance < 100) {\n  motor.backward();\n} else if (distance < 200) {\n  motor.stop();\n} else {\n  motor.forward();\n}\n",
                    "output": "Expected behavior:\n    \u2022 Stops if too close\n    \u2022 Goes forward otherwise"
                },
                "implementation": {
                    "explanation": "\u2705 4. ESP32 Robot Car Implementation\nWe now use:\n    \u2022 VL53L0X to detect obstacles\n    \u2022 L298N motor driver for movement\n    \u2022 OLED to show status\n    \u2022 Finite State Machine (FSM) to decide behavior\n\u2705 5. Explanation of Code Working\n\nBlock\nDescription\nVL53L0X sensor\nContinuously measures distance\nFSM states\nHandles behavior as: IDLE \u2192 FORWARD \u2192 AVOID \u2192 TURN \u2192 FORWARD\nDistance threshold\n< 100 mm \u2192 triggers obstacle avoidance\nOLED\nShows state and distance to monitor behavior\nmotor.backward()\nUsed to escape obstacle\nmotor.left()\nTurns to avoid and reroute\n\n\ud83e\udde0 Behavior Summary\n\nSituation\nRobot Action\nStartup\nWaits (IDLE)\nNo obstacle\nMoves forward\nObstacle detected (< 100 mm)\nBacks up\nAfter 1 sec of reverse\nTurns for 800 ms\nThen resumes forward motion\nKeeps navigating\n\n\u2705 Real-World Use\n\nThis basic logic can be expanded into:\n    \u2022 4-way obstacle detection (front, left, right, back)\n    \u2022 Path planning (zig-zag or room cleaning logic)\n    \u2022 Mapping with SLAM (advanced)\n",
                    "code": "#include <Wire.h>\n#include <VL53L0X.h>\n#include \"L298N.h\"\n#include <Adafruit_GFX.h>\n#include <Adafruit_SSD1306.h>\n\n// OLED\n#define SCREEN_WIDTH 128\n#define SCREEN_HEIGHT 64\nAdafruit_SSD1306 display(SCREEN_WIDTH, SCREEN_HEIGHT, &Wire, -1);\n\n// Motor & Sensor\nL298N motor(14, 27, 26);  // ENA, IN1, IN2\nVL53L0X sensor;\n\n// FSM States\nenum State { IDLE, FORWARD, AVOID, TURN };\nState state = IDLE;\nunsigned long stateStartTime = 0;\n\nvoid setup() {\n  Serial.begin(115200);\n  Wire.begin();\n\n  // OLED Init\n  if (!display.begin(SSD1306_SWITCHCAPVCC, 0x3C)) {\n    Serial.println(\"OLED init failed\");\n    while (1);\n  }\n\n  // Sensor Init\n  sensor.setTimeout(500);\n  if (!sensor.init()) {\n    Serial.println(\"Sensor failed\");\n    while (1);\n  }\n  sensor.startContinuous();\n  motor.setSpeed(180);\n  stateStartTime = millis();\n}\n\nvoid loop() {\n  int distance = sensor.readRangeContinuousMillimeters();\n\n  if (sensor.timeoutOccurred()) {\n    Serial.println(\"Timeout\");\n    motor.stop();\n    return;\n  }\n\n  // FSM Logic\n  switch (state) {\n    case IDLE:\n      motor.stop();\n      if (millis() - stateStartTime > 3000) {\n        state = FORWARD;\n        stateStartTime = millis();\n      }\n      break;\n\n    case FORWARD:\n      if (distance < 100) {\n        state = AVOID;\n        stateStartTime = millis();\n      } else {\n        motor.forward();\n      }\n      break;\n\n    case AVOID:\n      motor.backward();\n      if (millis() - stateStartTime > 1000) {\n        state = TURN;\n        stateStartTime = millis();\n      }\n      break;\n\n    case TURN:\n      motor.left();  // assuming you\u2019ve implemented left() in your L298N class\n      if (millis() - stateStartTime > 800) {\n        state = FORWARD;\n        stateStartTime = millis();\n      }\n      break;\n  }\n\n  // OLED Output\n  display.clearDisplay();\n  display.setCursor(0, 0);\n  display.setTextSize(1);\n  display.setTextColor(WHITE);\n  display.println(\"Obstacle Avoidance\");\n  display.print(\"State: \");\n  if (state == IDLE) display.println(\"IDLE\");\n  else if (state == FORWARD) display.println(\"FORWARD\");\n  else if (state == AVOID) display.println(\"AVOID\");\n  else if (state == TURN) display.println(\"TURN\");\n\n  display.print(\"Distance: \");\n  display.print(distance);\n  display.println(\" mm\");\n  display.display();\n\n  delay(50);\n}\n"
                }
            }
        }
    },
    "Robotics": {
        "levels": {}
    }
}